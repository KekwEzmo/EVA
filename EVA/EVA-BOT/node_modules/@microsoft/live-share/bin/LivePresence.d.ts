/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
import { DataObjectFactory } from "@fluidframework/aqueduct";
import { IEvent } from "@fluidframework/common-definitions";
import { LivePresenceUser, PresenceState } from "./LivePresenceUser";
import { UserMeetingRole } from "./interfaces";
import { LiveDataObject } from "./LiveDataObject";
/**
 * Events supported by `LivePresence` object.
 */
export declare enum LivePresenceEvents {
    /**
     * The presence for the local or a remote user has changed.
     */
    presenceChanged = "presenceChanged"
}
/**
 * Event typings for `LivePresence` class.
 * @template TData Type of data object to share with clients.
 */
export interface ILivePresenceEvents<TData extends object = object> extends IEvent {
    /**
     * The presence information for the local or a remote user has changed.
     * @param event Name of event.
     * @param listener Function called when event is triggered.
     * @param listener.user Presence information that changed.
     * @param listener.local If true the local client initiated this presence change.
     * @param listener.clientId The client ID for the user that send this message.
     */
    (event: "presenceChanged", listener: (user: LivePresenceUser<TData>, local: boolean, clientId: string) => void): any;
}
/**
 * Live fluid object that synchronizes presence information for the user with other clients.
 * @template TData Type of data object to share with clients.
 */
export declare class LivePresence<TData extends object = object> extends LiveDataObject<{
    Events: ILivePresenceEvents<TData>;
}> {
    private _logger?;
    private _expirationPeriod;
    private _users;
    private _lastEmitPresenceStateMap;
    private _currentPresence?;
    private _synchronizer?;
    /**
     * The objects fluid type/name.
     */
    static readonly TypeName = "@microsoft/live-share:LivePresence";
    /**
     * The objects fluid type factory.
     */
    static readonly factory: DataObjectFactory<LivePresence<object>, import("@fluidframework/aqueduct").DataObjectTypes>;
    /**
     * Number of seconds without a presence update before a remote user is considered offline.
     *
     * @remarks
     * Defaults to a value of `20` seconds. The minimum value is 0.1 seconds for testing purposes.
     */
    get expirationPeriod(): number;
    set expirationPeriod(value: number);
    /**
     * Local LivePresenceUser.
     * Can be undefined before LivePresence is initialized.
     */
    get localUser(): LivePresenceUser<TData> | undefined;
    /**
     * Initialize the object to begin sending/receiving presence updates through this DDS.
     *
     * @param data Optional. Custom data object to share. A deep copy of the data object is saved to avoid any accidental modifications.
     * @param state Optional. Initial presence state. Defaults to `PresenceState.online`.
     * @param allowedRoles Optional. List of roles allowed to emit presence changes.
     *
     * @returns a void promise that resolves once complete.
     *
     * @throws error when `.initialize()` has already been called for this class instance.
     * @throws fatal error when `.initialize()` has already been called for an object of same id but with a different class instance.
     * This is most common when using dynamic objects through Fluid.
     */
    initialize(data?: TData, state?: PresenceState, allowedRoles?: UserMeetingRole[]): Promise<void>;
    /**
     * Disposes of the object when its container is disposed of.
     */
    dispose(): void;
    /**
     * Returns a snapshot of the current list of presence objects being tracked.
     * @param filter Optional. Presence state to filter enumeration to.
     * @returns Array of presence objects.
     */
    getUsers(filter?: PresenceState): LivePresenceUser<TData>[];
    /**
     * Updates the local user's presence shared data object and/or state.
     *
     * @remarks
     * This will trigger the immediate broadcast of the users presence to all other clients.
     *
     * @param data Optional. Data object to change. A deep copy of the data object is saved to avoid any future changes.
     * @param state Optional. Presence state to change.
     *
     * @returns a void promise that resolves once the update event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    update(data?: TData, state?: PresenceState): Promise<void>;
    /**
     * Returns the current presence info for a specific client ID.
     * @param clientId The ID of the client to retrieve.
     * @returns The current presence information for the client if they've connected to the space.
     */
    getUserForClient(clientId: string): LivePresenceUser<TData> | undefined;
    /**
     * Returns the current presence info for a specific user.
     * @param userId The ID of the user to retrieve.
     * @returns The current presence information for the user if they've connected to the space.
     */
    getUser(userId: string): LivePresenceUser<TData> | undefined;
    /**
     * Internal method to send an update, with optional ability to throttle.
     */
    private updateInternal;
    /**
     * returns true if the change was applied to the member list
     */
    private updateMembersList;
    /**
     * For some reason, for non local users, tmp roster transiently doesn't contain a meeting participant.
     * When the particpant is missing the `info` matches `defaultUserInfo`.
     * @returns true if the info matches the default user info
     */
    private useTransientParticipantWorkaround;
    /**
     * Uses `updateMembersListWithInfo` with the latest value rather than using the incorrect default client info response.
     * @returns true if user presence record was updated
     */
    private transientParticipantWorkaround;
    private updateMembersListWithInfo;
}
//# sourceMappingURL=LivePresence.d.ts.map