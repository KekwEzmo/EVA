"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveShareClient = void 0;
const internals_1 = require("./internals");
const azure_client_1 = require("@fluidframework/azure-client");
const interfaces_1 = require("./interfaces");
const LocalTimestampProvider_1 = require("./LocalTimestampProvider");
const TestLiveShareHost_1 = require("./TestLiveShareHost");
const LiveShareRuntime_1 = require("./LiveShareRuntime");
const schema_injection_utils_1 = require("./schema-injection-utils");
/**
 * @hidden
 * Map v0.59 orderer endpoints to new v1.0 service endpoints
 */
const serviceEndpointMap = new Map()
    .set("https://alfred.westus2.fluidrelay.azure.com", "https://us.fluidrelay.azure.com")
    .set("https://alfred.westeurope.fluidrelay.azure.com", "https://eu.fluidrelay.azure.com")
    .set("https://alfred.southeastasia.fluidrelay.azure.com", "https://global.fluidrelay.azure.com");
/**
 * Client used to connect to fluid containers within a Microsoft Teams context.
 */
class LiveShareClient {
    /**
     * Creates a new `LiveShareClient` instance.
     * @param host Host for the current Live Share session.
     * @param options Optional. Configuration options for the client.
     */
    constructor(host, options) {
        this._host = TestLiveShareHost_1.TestLiveShareHost.create(undefined, undefined);
        /**
         * Number of times the client should attempt to get the ID of the container to join for the
         * current context.
         */
        this.maxContainerLookupTries = 3;
        // Validate host passed in
        if (!host) {
            throw new Error(`LiveShareClient: prop \`host\` is \`${host}\` when it is expected to be a non-optional value of type \`ILiveShareHost\`. Please ensure \`host\` is defined before initializing \`LiveShareClient\`.`);
        }
        if (typeof host.getFluidTenantInfo != "function") {
            throw new Error(`LiveShareClient: \`host.getFluidTenantInfo\` is of type \`${typeof host.getFluidTenantInfo}\` when it is expected to be a type of \`function\`. For more information, review the \`ILiveShareHost\` interface.`);
        }
        this._host = host;
        // Save options
        this._options = Object.assign(Object.assign({}, options), { timestampProvider: getIsTestClient(host, options)
                ? new LocalTimestampProvider_1.LocalTimestampProvider()
                : options === null || options === void 0 ? void 0 : options.timestampProvider });
        this._runtime = new LiveShareRuntime_1.LiveShareRuntime(this._host, this._options, true);
    }
    /**
     * If true the client is configured to use a local test server.
     */
    get isTesting() {
        return getIsTestClient(this._host, this._options);
    }
    /**
     * Setting for whether `LiveDataObject` instances using `LiveObjectSynchronizer` can send background updates.
     * Default value is `true`.
     *
     * @remarks
     * This is useful for scenarios where there are a large number of participants in a session, since service performance degrades as more socket connections are opened.
     * Intended for use when a small number of users are intended to be "in control", such as the `LiveFollowMode` class's `startPresenting()` feature.
     * There should always be at least one user in the session that has `canSendBackgroundUpdates` set to true.
     * Set to true when the user is eligible to send background updates (e.g., "in control"), or false when that user is not in control.
     * This setting will not prevent the local user from explicitly changing the state of objects using `LiveObjectSynchronizer`, such as `.set()` in `LiveState`.
     * Impacts background updates of `LiveState`, `LivePresence`, `LiveTimer`, and `LiveFollowMode`.
     */
    get canSendBackgroundUpdates() {
        return this._runtime.canSendBackgroundUpdates;
    }
    set canSendBackgroundUpdates(value) {
        this._runtime.canSendBackgroundUpdates = value;
    }
    /**
     * Connects to the fluid container for the current teams context.
     *
     * @remarks
     * The first client joining the container will create the container resulting in the
     * `onContainerFirstCreated` callback being called. This callback can be used to set the initial
     * state of of the containers object prior to the container being attached.
     * @param fluidContainerSchema Fluid objects to create.
     * @param onContainerFirstCreated Optional. Callback that's called when the container is first created.
     * @returns the results of join container.
     */
    joinContainer(fluidContainerSchema, onContainerFirstCreated) {
        return __awaiter(this, void 0, void 0, function* () {
            performance.mark(`TeamsSync: join container`);
            try {
                // Start runtime if needed
                const pStartRuntime = this._runtime.start();
                // Apply runtime to ContainerSchema
                const schema = (0, schema_injection_utils_1.getLiveShareContainerSchemaProxy)(fluidContainerSchema, this._runtime);
                // Initialize FRS connection config
                let config = this._options.connection;
                if (!config) {
                    const frsTenantInfo = yield this._host.getFluidTenantInfo();
                    // Compute endpoint
                    let endpoint = frsTenantInfo.serviceEndpoint;
                    if (!endpoint) {
                        if (serviceEndpointMap.has(frsTenantInfo.serviceEndpoint)) {
                            endpoint = serviceEndpointMap.get(frsTenantInfo.serviceEndpoint);
                        }
                        else {
                            throw new Error(`LiveShareClient: Unable to find fluid endpoint for: ${frsTenantInfo.serviceEndpoint}`);
                        }
                    }
                    // Is this a local config?
                    if (frsTenantInfo.tenantId == "local") {
                        config = {
                            type: "local",
                            endpoint: endpoint,
                            tokenProvider: yield (0, internals_1.getInsecureTokenProvider)(),
                        };
                    }
                    else {
                        config = {
                            type: "remote",
                            tenantId: frsTenantInfo.tenantId,
                            endpoint: endpoint,
                            tokenProvider: new internals_1.LiveShareTokenProvider(this._host),
                        };
                    }
                }
                // Create FRS client
                const client = new azure_client_1.AzureClient({
                    connection: config,
                    logger: this._options.logger,
                });
                // Create container on first access
                const pContainer = this.getOrCreateContainer(client, schema, 0, onContainerFirstCreated);
                // Wait in parallel for everything to finish initializing.
                const result = yield Promise.all([pContainer, pStartRuntime]);
                this._runtime.setAudience(result[0].services.audience);
                performance.mark(`TeamsSync: container connecting`);
                this._results = Object.assign(Object.assign({}, result[0]), { timestampProvider: this._runtime.timestampProvider });
                return this._results;
            }
            finally {
                performance.measure(`TeamsSync: container joined`, `TeamsSync: join container`);
            }
        });
    }
    getOrCreateContainer(client, fluidContainerSchema, tries, onInitializeContainer) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get container ID mapping
            const containerInfo = yield this._host.getFluidContainerId();
            // Create container on first access
            if (containerInfo.shouldCreate) {
                return yield this.createNewContainer(client, fluidContainerSchema, tries, onInitializeContainer);
            }
            else if (containerInfo.containerId) {
                return Object.assign({ created: false }, (yield client.getContainer(containerInfo.containerId, fluidContainerSchema)));
            }
            else if (tries < this.maxContainerLookupTries &&
                containerInfo.retryAfter > 0) {
                yield this.wait(containerInfo.retryAfter);
                return yield this.getOrCreateContainer(client, fluidContainerSchema, tries + 1, onInitializeContainer);
            }
            else {
                throw new Error(`LiveShareClient: timed out attempting to create or get container for current context.`);
            }
        });
    }
    createNewContainer(client, fluidContainerSchema, tries, onInitializeContainer) {
        return __awaiter(this, void 0, void 0, function* () {
            // Create and initialize container
            const { container, services } = yield client.createContainer(fluidContainerSchema);
            if (onInitializeContainer) {
                onInitializeContainer(container);
            }
            // Attach container to service
            const newContainerId = yield container.attach();
            // Attempt to save container ID mapping
            const containerInfo = yield this._host.setFluidContainerId(newContainerId);
            if (containerInfo.containerState != interfaces_1.ContainerState.added) {
                // Delete created container
                container.dispose();
                // Get mapped container ID
                return Object.assign({ created: false }, (yield client.getContainer(containerInfo.containerId, fluidContainerSchema)));
            }
            else {
                return { container, services, created: true };
            }
        });
    }
    wait(delay) {
        return new Promise((resolve) => {
            setTimeout(() => resolve(), delay);
        });
    }
}
exports.LiveShareClient = LiveShareClient;
function getIsTestClient(host, options) {
    var _a;
    return (((_a = options === null || options === void 0 ? void 0 : options.connection) === null || _a === void 0 ? void 0 : _a.type) == "local" ||
        host instanceof TestLiveShareHost_1.TestLiveShareHost);
}
//# sourceMappingURL=LiveShareClient.js.map