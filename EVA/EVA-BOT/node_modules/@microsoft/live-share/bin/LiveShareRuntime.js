"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveShareRuntime = void 0;
const common_utils_1 = require("@fluidframework/common-utils");
const HostTimestampProvider_1 = require("./HostTimestampProvider");
const internals_1 = require("./internals");
/**
 * Runtime for LiveDataObject, which is used to do things like validate roles, get a timestamp
 */
class LiveShareRuntime {
    /**
     * Runtime for `LiveDataObject`.
     *
     * @param host Host for the current Live Share session.
     * @param options Optional. Options used for initializing `LiveShareClient`.
     * @param decorate choose whether or not to automatically decorate host with `BackwardsCompatibilityHostDecorator` and `LiveShareHostDecorator`
     */
    constructor(host, options, decorate = true) {
        var _a, _b, _c;
        this._started = false;
        this._objectManager = null;
        // BackwardsCompatibilityHostDecorator is used for backwards compatibility with older versions of the Teams client.
        // LiveShareHostDecorator is used as a thin caching layer for some host APIs.
        this._host = decorate
            ? new internals_1.BackwardsCompatibilityHostDecorator(new internals_1.LiveShareHostDecorator(new internals_1.FormatFixHostDecorator(host)))
            : host;
        this._timestampProvider =
            (_a = options === null || options === void 0 ? void 0 : options.timestampProvider) !== null && _a !== void 0 ? _a : new HostTimestampProvider_1.HostTimestampProvider(this._host);
        this._roleVerifier =
            (_b = options === null || options === void 0 ? void 0 : options.roleVerifier) !== null && _b !== void 0 ? _b : new internals_1.RoleVerifier(this._host);
        this._canSendBackgroundUpdates =
            (_c = options === null || options === void 0 ? void 0 : options.canSendBackgroundUpdates) !== null && _c !== void 0 ? _c : true;
    }
    /**
     * `LiveObjectSynchronizerManager` instance
     */
    get objectManager() {
        (0, common_utils_1.assert)(this._objectManager !== null, "LiveObjectSynchronizerManager not initialized.");
        return this._objectManager;
    }
    /**
     * `ITimestampProvider` instance
     */
    get timestampProvider() {
        return this._timestampProvider;
    }
    /**
     * `ILiveShareHost` instance
     */
    get host() {
        return this._host;
    }
    /**
     * Setting for whether `LiveDataObject` instances using `LiveObjectSynchronizer` can send background updates.
     * Default value is `true`.
     *
     * @remarks
     * This is useful for scenarios where there are a large number of participants in a session, since service performance degrades as more socket connections are opened.
     * Intended for use when a small number of users are intended to be "in control", such as the `LiveFollowMode` class's `startPresenting()` feature.
     * There should always be at least one user in the session that has `canSendBackgroundUpdates` set to true.
     * Set to true when the user is eligible to send background updates (e.g., "in control"), or false when that user is not in control.
     * This setting will not prevent the local user from explicitly changing the state of objects using `LiveObjectSynchronizer`, such as `.set()` in `LiveState`.
     * Impacts background updates of `LiveState`, `LivePresence`, `LiveTimer`, and `LiveFollowMode`.
     */
    get canSendBackgroundUpdates() {
        return this._canSendBackgroundUpdates;
    }
    set canSendBackgroundUpdates(value) {
        this._canSendBackgroundUpdates = value;
    }
    /**
     * Returns the current timestamp as the number of milliseconds sine the Unix Epoch.
     */
    getTimestamp() {
        return this._timestampProvider.getTimestamp();
    }
    /**
     * Verifies that a client has one of the specified roles.
     * @param clientId Client ID to inspect.
     * @param allowedRoles User roles that are allowed.
     * @returns True if the client has one of the specified roles.
     */
    verifyRolesAllowed(clientId, allowedRoles) {
        return this._roleVerifier.verifyRolesAllowed(clientId, allowedRoles);
    }
    /**
     * Get the client info for a given clientId
     * @param clientId Fluid clientId we are requesting user info for
     * @returns IClientInfo object if the user is known, otherwise it will return undefined
     */
    getClientInfo(clientId) {
        return this._host.getClientInfo(clientId);
    }
    /**
     * @hidden
     * Set the timestamp provider for the runtime
     * @param timestampProvider timestamp provider to set
     */
    setTimestampProvider(timestampProvider) {
        this._timestampProvider = timestampProvider;
    }
    /**
     * @hidden
     * Set the role verifier for the runtime
     * @param roleVerifier role verifier to set
     */
    setRoleVerifier(roleVerifier) {
        this._roleVerifier = roleVerifier;
    }
    /**
     * Set the host for the runtime
     * @param host ILiveShareHost to change
     * @param decorate choose whether or not to automatically decorate host with `BackwardsCompatibilityHostDecorator` and `LiveShareHostDecorator`
     */
    setHost(host, decorate = true) {
        // BackwardsCompatibilityHostDecorator is used for backwards compatibility with older versions of the Teams client.
        // LiveShareHostDecorator is used as a thin caching layer for some host APIs.
        this._host = decorate
            ? new internals_1.BackwardsCompatibilityHostDecorator(new internals_1.LiveShareHostDecorator(host))
            : host;
        if (this._timestampProvider instanceof HostTimestampProvider_1.HostTimestampProvider) {
            this._timestampProvider.stop();
            this.setTimestampProvider(new HostTimestampProvider_1.HostTimestampProvider(this._host));
        }
        if (this._roleVerifier instanceof internals_1.RoleVerifier) {
            this.setRoleVerifier(new internals_1.RoleVerifier(this._host));
        }
    }
    /**
     * Set the audience for the runtime
     * @param audience `IAzureAudience` returned by `AzureClient`
     */
    setAudience(audience) {
        var _a;
        this._audience = audience;
        (_a = this._objectManager) === null || _a === void 0 ? void 0 : _a.setAudience(this._audience);
    }
    /**
     * Start the timestamp provider
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._started) {
                throw new Error("LiveShareRuntime.start(): cannot call start when already started");
            }
            this._started = true;
            if (this._objectManager) {
                this.startObjectSynchronizerManager();
            }
            // Start provider if needed
            if ((0, internals_1.isTimestampProvider)(this._timestampProvider) &&
                !this._timestampProvider.isRunning) {
                yield this._timestampProvider.start();
            }
        });
    }
    /**
     * Stop the timestamp provider
     */
    stop() {
        var _a;
        if (!this._started) {
            throw new Error("LiveShareRuntime.stop(): cannot call stop when not already started");
        }
        this._started = false;
        // Start provider if needed
        if ((0, internals_1.isTimestampProvider)(this._timestampProvider) &&
            this._timestampProvider.isRunning) {
            this._timestampProvider.stop();
        }
        // should not assert undefined if stopping in a unit test context
        (_a = this._objectManager) === null || _a === void 0 ? void 0 : _a.stop();
    }
    /**
     * @hidden
     * Do not use this API unless you know what you are doing.
     * Using it incorrectly could cause object synchronizers to stop working.
     */
    __dangerouslySetContainerRuntime(cRuntime) {
        // Fluid normally will create new DDS instances with the same runtime, but during some instances they will re-instantiate it.
        if (this._containerRuntime === cRuntime)
            return;
        // If we already have a _containerRuntime, we technically do not need to re-set it, despite them re-instantiating it.
        // This is because for how we are using it (signals), this has no impact. We still swap out our reference and reset signal
        // event listeners, both for future proofing and as a general good memory practice to avoid unintentionally create floating references.
        this._containerRuntime = cRuntime;
        // If we already have a LiveObjectManager instance, we reset their reference to the container runtime as well
        if (this._objectManager) {
            this._objectManager.__dangerouslySetContainerRuntime(cRuntime);
            return;
        }
        this._objectManager = new internals_1.LiveObjectManager(this, this._containerRuntime);
        this.startObjectSynchronizerManager();
    }
    /**
     * @hidden
     */
    startObjectSynchronizerManager() {
        // If this is being set after the objectManager was started,
        this.objectManager.start();
    }
}
exports.LiveShareRuntime = LiveShareRuntime;
//# sourceMappingURL=LiveShareRuntime.js.map