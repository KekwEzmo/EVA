"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AzureLiveShareHost = void 0;
const interfaces_1 = require("./interfaces");
const internals_1 = require("./internals");
/**
 * @alpha
 * This host enables using Live Share through your own `AzureClient` implementation.
 * This is not intended to be used with `LiveShareClient`.
 * We provide no SLA guarantees on this implementation while it is in alpha.
 *
 * @remarks
 * To use this API, first pass your `ContainerSchema` through the `getLiveShareContainerSchemaProxy` function.
 * This should be done before calling `.getContainer()` or `createContainer()`.
 * Then, call `setAudience()` with the `IAzureAudience` object (in `AzureContainerServices`) returned by the `AzureClient`.
 */
class AzureLiveShareHost {
    /**
     * @hidden
     */
    constructor(_shouldWarnLocalTimestamp) {
        this._shouldWarnLocalTimestamp = _shouldWarnLocalTimestamp;
        this._azureAudienceDeferred = new internals_1.Deferred();
        this.hasWarned = false;
    }
    /**
     * @beta
     * Static constructor for host enables using Live Share through your own `AzureClient` implementation.
     * @param azureAudience the Azure Audience object for your Fluid container
     * @param shouldWarnLocalTimestamp warning for using the local timestamp value for `getNptTime`.
     * @returns new `AzureLiveShareHost` instance
     */
    static create(shouldWarn = true) {
        return new AzureLiveShareHost(shouldWarn);
    }
    /**
     * This function should be called immediately after getting audience from `AzureClient`.
     * @param audience Azure Audience
     */
    setAudience(audience) {
        this._azureAudienceDeferred.resolve(audience);
    }
    /**
     * Register doesn't do anything special here, since we are using AzureAudience in this host
     * @see ILiveShareHost.registerClientId
     */
    registerClientId(clientId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const clientInfo = yield this.getClientInfo(clientId);
            return (_a = clientInfo === null || clientInfo === void 0 ? void 0 : clientInfo.roles) !== null && _a !== void 0 ? _a : [];
        });
    }
    /**
     * Gets the corresponding `AzureAudience` `IClientInfo` for a given `clientId`
     * @see ILiveShareHost.getClientInfo
     */
    getClientInfo(clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            const audienceInfo = yield this.getAudienceMemberInfo(clientId);
            if (!audienceInfo) {
                throw new Error(`AzureLiveShareHost.getClientInfo: audience member not found`);
            }
            return {
                userId: audienceInfo.userId,
                roles: this.getRolesForAudienceMember(audienceInfo),
                displayName: audienceInfo.userName,
            };
        });
    }
    /**
     * Uses local timestamp by default.
     * @remarks
     * To remove warning, either set shouldWarn in `.create()`, or override this value with a timestamp from a server.
     *
     * @see ILiveShareHost.getNtpTime
     */
    getNtpTime() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasWarned && this._shouldWarnLocalTimestamp) {
                console.warn(`AzureLiveShareHost is using a local timestamp, which could cause issues when use some LiveDataObject data structures across multiple clients.\n
                To disable this warning, set _shouldWarn in AzureLiveShareHost.create() to false.\n
                To resolve synchronization issues you may encounter, you should implement a service API to get this timestamp value and override this function.`);
                this.hasWarned = true;
            }
            const now = new Date();
            return Promise.resolve({
                ntpTime: now.toUTCString(),
                ntpTimeInUTC: now.getTime(),
            });
        });
    }
    /**
     * @deprecated
     * @see ILiveShareHost.getClientRoles
     */
    getClientRoles(clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            const clientInfo = yield this.getClientInfo(clientId);
            return clientInfo === null || clientInfo === void 0 ? void 0 : clientInfo.roles;
        });
    }
    /**
     * Will throw not implemented exception. Extend this class and override this function when using with `LiveShareClient`.
     * @see ILiveShareHost.getFluidTenantInfo
     */
    getFluidTenantInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("AzureLiveShareHost.getFluidTenantInfo: not implemented exception");
        });
    }
    /**
     * Will throw not implemented exception. Extend this class and override this function when using with `LiveShareClient`.
     * @see ILiveShareHost.getFluidToken
     */
    getFluidToken(containerId) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("AzureLiveShareHost.getFluidToken: not implemented exception");
        });
    }
    /**
     * Will throw not implemented exception. Extend this class and override this function when using with `LiveShareClient`.
     * @see ILiveShareHost.getFluidContainerId
     */
    getFluidContainerId() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("AzureLiveShareHost.getFluidContainerId: not implemented exception");
        });
    }
    /**
     * Will throw not implemented exception. Extend this class and override this function when using with `LiveShareClient`.
     * @see ILiveShareHost.setFluidContainerId
     */
    setFluidContainerId(containerId) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("AzureLiveShareHost.setFluidContainerId: not implemented exception");
        });
    }
    /**
     * @hidden
     */
    getAudienceMemberInfo(clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            const members = (yield this._azureAudienceDeferred.promise).getMembers();
            // It's possible that the clientId is an older one, so we check member's connection history for a match
            const memberValues = [...members.values()];
            for (let checkIndex = 0; checkIndex < memberValues.length; checkIndex++) {
                const checkMember = memberValues[checkIndex];
                if (checkMember.connections.find((connection) => connection.id === clientId)) {
                    return checkMember;
                }
            }
            return undefined;
        });
    }
    /**
     * @hidden
     */
    getRolesForAudienceMember(member) {
        if (member.connections.length === 0) {
            return [];
        }
        const mostRecentConnection = member.connections[member.connections.length - 1];
        if (mostRecentConnection.mode === "write") {
            // Return presenter role as a signifier of write access.
            // Organizer permission not supported by this host.
            return [interfaces_1.UserMeetingRole.presenter];
        }
        // Return presenter role as a signifier of write access.
        // Guest permission not supported by this host.
        return [interfaces_1.UserMeetingRole.attendee];
    }
}
exports.AzureLiveShareHost = AzureLiveShareHost;
//# sourceMappingURL=AzureLiveShareHost.js.map