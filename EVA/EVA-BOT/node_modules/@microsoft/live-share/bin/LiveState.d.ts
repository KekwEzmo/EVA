/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
import { DataObjectFactory } from "@fluidframework/aqueduct";
import { IEvent } from "@fluidframework/common-definitions";
import { UserMeetingRole } from "./interfaces";
import { LiveDataObject } from "./LiveDataObject";
/**
 * Events supported by [LiveState` object.
 */
export declare enum LiveStateEvents {
    /**
     * The objects state has changed.
     */
    stateChanged = "stateChanged"
}
/**
 * Event typings for `LiveState` class.
 * @template TState State object that's synchronized with the state.
 */
export interface ILiveStateEvents<TState = any> extends IEvent {
    /**
     * An `LiveState` objects state has changed.
     * @param event Name of event.
     * @param listener Function called when event is triggered.
     * @param listener.state The new state. Can be the same as the previous state.
     * @param listener.local If true, a local state change occurred.
     * @param listener.clientId clientId of sender.
     * @param listener.timestamp timestamp the time message was sent, according to `LiveShareRuntime.getTimestamp()`
     */
    (event: "stateChanged", listener: (state: TState, local: boolean, clientId: string, timestamp: number) => void): any;
}
/**
 * Live fluid object that synchronizes a named state and optional data value across clients.
 *
 * @remarks
 * The primary benefit of using the `LiveState` object in a Teams meeting, versus something
 * like a `SharedMap`, is that you can restrict the roles of who's allowed to perform state
 * changes.
 * @template TState Optional data object that's synchronized with the state.
 */
export declare class LiveState<TState = any> extends LiveDataObject<{
    Events: ILiveStateEvents<TState>;
}> {
    private _logger?;
    private _latestEvent?;
    private _synchronizer?;
    /**
     * The objects fluid type/name.
     */
    static readonly TypeName = "@microsoft/live-share:LiveState";
    /**
     * The objects fluid type factory.
     */
    static readonly factory: DataObjectFactory<LiveState<any>, import("@fluidframework/aqueduct").DataObjectTypes>;
    /**
     * The current state.
     */
    get state(): TState;
    /**
     * Initialize the object to begin sending/receiving state updates through this DDS.
     *
     * @param initialState Initial state value
     * @param allowedRoles Optional. List of roles allowed to make state changes.
     *
     * @returns a void promise that resolves once complete
     *
     * @throws error when `.initialize()` has already been called for this class instance.
     * @throws fatal error when `.initialize()` has already been called for an object of same id but with a different class instance.
     * This is most common when using dynamic objects through Fluid.
     */
    initialize(initialState: TState, allowedRoles?: UserMeetingRole[]): Promise<void>;
    /**
     * Disposes of the object when its container is disposed of.
     */
    dispose(): void;
    /**
     * Set a new state value
     *
     * @param state New state value.
     *
     * @returns a void promise that resolves once the set event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    set(state: TState): Promise<void>;
    /**
     * The current state.
     */
    private get latestEvent();
    /**
     * The current state.
     */
    private set latestEvent(value);
    private onReceivedStateEvent;
    private updateState;
}
//# sourceMappingURL=LiveState.d.ts.map