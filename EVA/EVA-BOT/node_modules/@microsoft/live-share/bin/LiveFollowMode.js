"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveFollowMode = exports.FollowModeType = exports.LiveFollowModeEvents = void 0;
const LiveDataObject_1 = require("./LiveDataObject");
const LiveState_1 = require("./LiveState");
const LivePresence_1 = require("./LivePresence");
const aqueduct_1 = require("@fluidframework/aqueduct");
const common_utils_1 = require("@fluidframework/common-utils");
const interfaces_1 = require("./interfaces");
const LiveTelemetryLogger_1 = require("./LiveTelemetryLogger");
const LivePresenceUser_1 = require("./LivePresenceUser");
const DynamicObjectRegistry_1 = require("./DynamicObjectRegistry");
/**
 * @beta
 *
 * Events supported by `LiveFollowMode` object.
 */
var LiveFollowModeEvents;
(function (LiveFollowModeEvents) {
    /**
     * The follow mode state changed.
     */
    LiveFollowModeEvents["stateChanged"] = "stateChanged";
    /**
     * A user's presence state changed.
     */
    LiveFollowModeEvents["presenceChanged"] = "presenceChanged";
})(LiveFollowModeEvents = exports.LiveFollowModeEvents || (exports.LiveFollowModeEvents = {}));
/**
 * @beta
 *
 * The follow mode type.
 *
 * @remarks
 * Determines which user's `stateValue` is being referenced by `LiveFollowMode`'s `state.value` field.
 * Use to tell the user the current state of follow mode (e.g., "You are actively presenting").
 * Use to determine any relevant button(s) to show to the user (e.g., "Stop presenting").
 */
var FollowModeType;
(function (FollowModeType) {
    /**
     * Local user is not following anyone, there is no presenter, and nobody is following them.
     */
    FollowModeType["local"] = "local";
    /**
     * Local user is being followed by other remote users.
     */
    FollowModeType["activeFollowers"] = "activeFollowers";
    /**
     * Local user is actively presenting to other users.
     */
    FollowModeType["activePresenter"] = "activePresenter";
    /**
     * Local user is following the presenter and is in sync.
     */
    FollowModeType["followPresenter"] = "followPresenter";
    /**
     * The local user is suspended from the remote active presenter.
     */
    FollowModeType["suspendFollowPresenter"] = "suspendFollowPresenter";
    /**
     * Local user is following a specific user and is in sync.
     */
    FollowModeType["followUser"] = "followUser";
    /**
     * The local user is suspended from following a specific user.
     */
    FollowModeType["suspendFollowUser"] = "suspendFollowUser";
})(FollowModeType = exports.FollowModeType || (exports.FollowModeType = {}));
const presentingUserIdLiveStateKey = "<<presentingUserIdLiveStateKey>>";
const livePresenceKey = "<<livePresenceKey>>";
/**
 * @beta
 *
 * Live object that allows users to present and/or follow other users.
 * Provides a {@link state} value, which reflects the relevant value to reference (e.g., the presenting user's state value).
 *
 * @template TData Type of data value to share with clients for each user (e.g., the user's camera position in a 3D scene).
 */
class LiveFollowMode extends LiveDataObject_1.LiveDataObject {
    constructor() {
        super(...arguments);
        /**
         * Flag for whether the local user is out of sync with the person they are following.
         * Defaults to false, even if the user is not following anyone.
         */
        this._suspended = false;
    }
    /**
     * Gets the current follow mode state.
     *
     * @remarks
     * Value is {@link IFollowModeState} when follow mode state is ready to access, and undefined when pending.
     */
    get state() {
        const localUser = this.presence.localUser;
        if (!localUser || !localUser.data) {
            return undefined;
        }
        const presentingUser = this.presentingUserIdState.state
            ? this.presence.getUser(this.presentingUserIdState.state)
            : undefined;
        if (presentingUser && presentingUser.data) {
            // Count is all online users minus the presenting user
            const otherUsersCount = this.getUsers(LivePresenceUser_1.PresenceState.online).length - 1;
            if (presentingUser.isLocalUser) {
                // The local user is the presenter
                return {
                    value: presentingUser.data.stateValue,
                    followingUserId: presentingUser.userId,
                    type: FollowModeType.activePresenter,
                    otherUsersCount,
                    isLocalValue: true,
                };
            }
            if (this._suspended) {
                // There is a presenting user but the local user is suspended
                return {
                    value: localUser.data.stateValue,
                    followingUserId: presentingUser.userId,
                    type: FollowModeType.suspendFollowPresenter,
                    otherUsersCount: otherUsersCount - 1,
                    isLocalValue: true,
                };
            }
            // There is a presenting user and the local user is in sync
            return {
                value: presentingUser.data.stateValue,
                followingUserId: presentingUser.userId,
                type: FollowModeType.followPresenter,
                // don't want to count the local user in otherUsersCount
                otherUsersCount: otherUsersCount - 1,
                isLocalValue: false,
            };
        }
        const followingUser = localUser.data.followingUserId
            ? this.presence.getUser(localUser.data.followingUserId)
            : undefined;
        if (followingUser && followingUser.data) {
            const otherUsersCount = this.getUserFollowers(followingUser.userId, LivePresenceUser_1.PresenceState.online).length - 1;
            if (this._suspended) {
                // Local user is following specific user but is suspended
                return {
                    value: localUser.data.stateValue,
                    followingUserId: followingUser.userId,
                    type: FollowModeType.suspendFollowUser,
                    otherUsersCount,
                    isLocalValue: true,
                };
            }
            // Local user is following a specific user and is in sync
            return {
                value: followingUser.data.stateValue,
                followingUserId: followingUser.userId,
                type: FollowModeType.followUser,
                otherUsersCount,
                isLocalValue: false,
            };
        }
        const userCountFollowingLocalUser = this.getUserFollowers(localUser.userId, LivePresenceUser_1.PresenceState.online).length;
        if (userCountFollowingLocalUser > 0) {
            // User is being followed by other users
            return {
                value: localUser.data.stateValue,
                followingUserId: localUser.userId,
                type: FollowModeType.activeFollowers,
                otherUsersCount: userCountFollowingLocalUser,
                isLocalValue: true,
            };
        }
        // User is not following anyone and nobody is presenting
        return {
            value: localUser.data.stateValue,
            followingUserId: localUser.userId,
            type: FollowModeType.local,
            otherUsersCount: this.getUserFollowers(localUser.userId, LivePresenceUser_1.PresenceState.online).length,
            isLocalValue: true,
        };
    }
    /**
     * Local LivePresenceUser.
     * Can be undefined before LiveFollowMode is initialized.
     */
    get localUser() {
        return this.presence.localUser;
    }
    /**
     * Convenience getter to get the `_dynamicObjectsCollection` without having to check for undefined, since this will
     * never be undefined after `initializingFirstTime`.
     */
    get presentingUserIdState() {
        (0, common_utils_1.assert)(this._presentingUserIdState !== undefined, "_presentingUserIdState not initialized");
        return this._presentingUserIdState;
    }
    /**
     * Convenience getter to get the `_dynamicObjectsCollection` without having to check for undefined, since this will
     * never be undefined after `initializingFirstTime`.
     */
    get presence() {
        (0, common_utils_1.assert)(this._presence !== undefined, "_presence not initialized");
        return this._presence;
    }
    /**
     * Initialize the object to begin sending/receiving state updates through this DDS.
     *
     * @param initialState Initial state value
     * @param allowedRoles Optional. List of roles allowed to make state changes.
     *
     * @returns a void promise that resolves once complete
     *
     * @throws error when `.initialize()` has already been called for this class instance.
     * @throws fatal error when `.initialize()` has already been called for an object of same id but with a different class instance.
     * This is most common when using dynamic objects through Fluid.
     */
    initialize(initialState, allowedRoles) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.needed) {
                throw new Error(`LiveFollowMode already started.`);
            }
            // Update initialize state as pending
            this.initializeState = interfaces_1.LiveDataObjectInitializeState.pending;
            this._logger = new LiveTelemetryLogger_1.LiveTelemetryLogger(this.runtime, this.liveRuntime);
            this.presentingUserIdState.on("stateChanged", (state, local, clientId) => {
                // Reset out of sync flag whenever the following user changes
                this._suspended = false;
                this.handlePotentialStateChange(local, clientId);
            });
            this.presence.on("presenceChanged", (user, local, clientId) => {
                this.handlePotentialStateChange(local, clientId);
                // Emit presenceChanged event
                this.emit("presenceChanged", user, local, clientId);
            });
            try {
                yield Promise.all([
                    this.presentingUserIdState.initialize(undefined, allowedRoles),
                    this.presence.initialize({
                        stateValue: initialState,
                        followingUserId: undefined,
                    }),
                ]);
            }
            catch (error) {
                // Update state as fatal
                this.initializeState = interfaces_1.LiveDataObjectInitializeState.fatalError;
                throw error;
            }
            // Update initialize state as succeeded
            this.initializeState = interfaces_1.LiveDataObjectInitializeState.succeeded;
        });
    }
    /**
     * Broadcast a new custom data value for the local user's current state.
     *
     * @remarks
     * Each user has their own state value, though it will differ from what is shown in {@link state} depending on the value of {@link FollowModeType}.
     * Will cause the user to become out of sync if another user is presenting or the local user is following another user.
     * To see each user's state, use the {@link getUsers} API, or listen to "presenceChanged" updates.
     *
     * @param newValue the state value for the local user's presence record.
     *
     * @returns a void promise that resolves once the update event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     */
    update(newValue) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveFollowMode: not initialized prior to calling \`.update()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            if (!((_a = this.presence.localUser) === null || _a === void 0 ? void 0 : _a.data)) {
                throw new Error(`LiveFollowMode: invalid local user's current state value when calling \`.followUser()\`, implying there was an error during initialization that should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            // Send the new stateValue through presence
            yield this.presence.update({
                stateValue: newValue,
                followingUserId: this.presence.localUser.data.followingUserId,
            });
        });
    }
    /**
     * Start presenting the local user's state.
     *
     * @remarks
     * If another user is already presenting, the local user will take control of presenting from the previous presenter.
     * To update the local user's state that both the local and remote users will reference, use the {@link update} function.
     * This API will override any `followingUserId` value that was set through {@link followUser} until presenting has stopped.
     * To stop presenting, use the {@link stopPresenting} API.
     *
     * @returns a void promise that resolves once the event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user is already the presenter.
     * @throws error if the local user does not have the required roles to present.
     */
    startPresenting() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveFollowMode: not initialized prior to calling \`.followUser()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            if (!((_a = this.presence.localUser) === null || _a === void 0 ? void 0 : _a.data)) {
                throw new Error(`LiveFollowMode: invalid local user's current state value when calling \`.followUser()\`, implying there was an error during initialization that should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            if (this.presence.localUser.userId === this.presentingUserIdState.state) {
                throw new Error(`LiveFollowMode: the local user is already the active presenter. To stop presenting, use the \`.stopPresenting()\` function.`);
            }
            // Set presentingUserIdState to the local user's userId
            yield this.presentingUserIdState.set(this.presence.localUser.userId);
        });
    }
    /**
     * Stop presenting the presenting user's current state.
     *
     * @remarks
     * This API allows any user with valid roles to cancel presenting, though we generally recommend only allowing the active presenter to do so.
     * To start presenting, use the {@link startPresenting} API.
     *
     * @returns a void promise that resolves once the event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles to stop presenting.
     */
    stopPresenting() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveFollowMode: not initialized prior to calling \`.followUser()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            if (!((_a = this.presence.localUser) === null || _a === void 0 ? void 0 : _a.data)) {
                throw new Error(`LiveFollowMode: invalid local user's current state value when calling \`.followUser()\`, implying there was an error during initialization that should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            // Set presentingUserIdState to undefined
            yield this.presentingUserIdState.set(undefined);
        });
    }
    /**
     * Temporarily stop following presenter/follower.
     *
     * @returns a void promise once the operation succeeds.
     *
     * @throws error if initialization has not yet succeeded.
     */
    beginSuspension() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveFollowMode: not initialized prior to calling \`.followUser()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            if (!((_a = this.presence.localUser) === null || _a === void 0 ? void 0 : _a.data)) {
                throw new Error(`LiveFollowMode: invalid local user's current state value when calling \`.followUser()\`, implying there was an error during initialization that should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            this._suspended = true;
            this.handlePotentialStateChange(true, yield this.waitUntilConnected());
        });
    }
    /**
     * Resume following presenter/follower.
     *
     * @returns a void promise once the operation succeeds.
     *
     * @throws error if initialization has not yet succeeded.
     */
    endSuspension() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveFollowMode: not initialized prior to calling \`.followUser()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            if (!((_a = this.presence.localUser) === null || _a === void 0 ? void 0 : _a.data)) {
                throw new Error(`LiveFollowMode: invalid local user's current state value when calling \`.followUser()\`, implying there was an error during initialization that should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            this._suspended = false;
            this.handlePotentialStateChange(true, yield this.waitUntilConnected());
        });
    }
    /**
     * Follows another user in the session.
     *
     * @remarks
     * If another user is presenting, {@link state} will not reflect following this user until there is no longer a presenter.
     *
     * @param userId the userId for the user to follow.
     *
     * @returns a void promise that resolves once the event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if attempting to follow a user that is not recognized by this object's `LivePresence` instance.
     * @throws error if the `userId` provided is equal to the local user's `userId`.
     */
    followUser(userId) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveFollowMode: not initialized prior to calling \`.followUser()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            if (!((_a = this.presence.localUser) === null || _a === void 0 ? void 0 : _a.data)) {
                throw new Error(`LiveFollowMode: invalid local user's current state value when calling \`.followUser()\`, implying there was an error during initialization that should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            const user = this.presence.getUser(userId);
            if (!user) {
                throw new Error(`LiveFollowMode: cannot find user for provided \`userId\` of ${userId}. Ensure remote user for this userId has also called \`.initialize()\`.`);
            }
            if (user.isLocalUser) {
                throw new Error("LiveFollowMode: local user cannot follow themselves. If you are trying to stop following another user, instead use the `.stopFollowing()` function.");
            }
            // Update followingUserId for presence
            yield this.presence.update({
                stateValue: this.presence.localUser.data.stateValue,
                followingUserId: userId,
            });
        });
    }
    /**
     * Stop following the currently following user.
     *
     * @returns a void promise that resolves once the event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the user is not already following another user.
     */
    stopFollowing() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveFollowMode: not initialized prior to calling \`.stopFollowing()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            if (!((_a = this.presence.localUser) === null || _a === void 0 ? void 0 : _a.data)) {
                throw new Error(`LiveFollowMode: invalid local user's current state value when calling \`.stopFollowing()\`, implying there was an error during initialization that should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            if (!this.presence.localUser.data.followingUserId) {
                throw new Error(`LiveFollowMode: the local user is not following another user.\nTo fix this error, ensure that \`.followUser()\` has resolved before calling this function.`);
            }
            // Update followingUserId for presence
            yield this.presence.update({
                stateValue: this.presence.localUser.data.stateValue,
                followingUserId: undefined,
            });
        });
    }
    /**
     * Returns a snapshot of the current list of presence objects being tracked.
     * @param filter Optional. Presence state to filter enumeration to.
     * @returns Array of presence objects.
     */
    getUsers(filter) {
        return this.presence.getUsers(filter);
    }
    /**
     * Returns the current presence info for a specific user.
     * @param userId The ID of the user to retrieve.
     * @returns The current presence information for the user if they've connected to the space.
     */
    getUser(userId) {
        return this.presence.getUser(userId);
    }
    /**
     * Returns the current presence info for a specific client ID.
     * @param clientId The ID of the client to retrieve.
     * @returns The current presence information for the client if they've connected to the space.
     */
    getUserForClient(clientId) {
        return this.presence.getUserForClient(clientId);
    }
    /**
     * Get the users that are following a given userId.
     *
     * @param userId the userId of the person being followed.
     * @param stateFilter the presence state to filter results by.
     */
    getUserFollowers(userId, stateFilter) {
        const users = this.getUsers(stateFilter);
        return users.filter((user) => { var _a; return ((_a = user.data) === null || _a === void 0 ? void 0 : _a.followingUserId) === userId; });
    }
    /**
     * Disposes of the object when its container is disposed of.
     */
    dispose() {
        super.dispose();
        this.presence.dispose();
        this.presentingUserIdState.dispose();
    }
    /**
     * initializingFirstTime is run only once by the first client to create the DataObject. Here we use it to
     * initialize the state of the DataObject.
     */
    initializingFirstTime() {
        return __awaiter(this, void 0, void 0, function* () {
            // We create the live state instance
            const presentingUserIdLiveStatePromise = LiveState_1.LiveState.factory.createChildInstance(this.context);
            // We create the live state instance
            const livePresencePromise = LivePresence_1.LivePresence.factory.createChildInstance(this.context);
            try {
                const [presentingUserLiveState, livePresence] = yield Promise.all([
                    presentingUserIdLiveStatePromise,
                    livePresencePromise,
                ]);
                // Set object(s) to root
                this.root.set(presentingUserIdLiveStateKey, presentingUserLiveState.handle);
                this.root.set(livePresenceKey, livePresence.handle);
            }
            catch (err) {
                console.log(err);
            }
        });
    }
    /**
     * hasInitialized is run by each client as they load the DataObject.  Here we use it to initialize the
     * task manager, listen for task assignments, and listen for changes to the dynamic objects map.
     */
    hasInitialized() {
        return __awaiter(this, void 0, void 0, function* () {
            // Get object handles
            const presentingUserIdLiveStateHandle = this.root.get(presentingUserIdLiveStateKey);
            const presenceHandle = this.root.get(livePresenceKey);
            const [liveState, livePresence] = yield Promise.all([
                presentingUserIdLiveStateHandle === null || presentingUserIdLiveStateHandle === void 0 ? void 0 : presentingUserIdLiveStateHandle.get(),
                presenceHandle === null || presenceHandle === void 0 ? void 0 : presenceHandle.get(),
            ]);
            liveState === null || liveState === void 0 ? void 0 : liveState.__dangerouslySetLiveRuntime(this.liveRuntime);
            livePresence === null || livePresence === void 0 ? void 0 : livePresence.__dangerouslySetLiveRuntime(this.liveRuntime);
            this._presentingUserIdState = liveState;
            this._presence = livePresence;
        });
    }
    /**
     * Checks if the state has changed since we last checked, and if so, emits change.
     */
    handlePotentialStateChange(local, clientId) {
        const newState = this.state;
        if (JSON.stringify(newState) === JSON.stringify(this._recentState)) {
            return;
        }
        this._recentState = newState;
        this.emit("stateChanged", newState, local, clientId);
    }
}
/**
 * The objects fluid type/name.
 */
LiveFollowMode.TypeName = `@microsoft/live-share:LiveFollowMode`;
/**
 * The objects fluid type factory.
 */
LiveFollowMode.factory = new aqueduct_1.DataObjectFactory(LiveFollowMode.TypeName, LiveFollowMode, [], {}, new Map([
    LiveState_1.LiveState.factory.registryEntry,
    LivePresence_1.LivePresence.factory.registryEntry,
]));
exports.LiveFollowMode = LiveFollowMode;
/**
 * Register `LiveFollowMode` as an available `LoadableObjectClass` for use in packages that support dynamic object loading, such as `@microsoft/live-share-turbo`.
 */
DynamicObjectRegistry_1.DynamicObjectRegistry.registerObjectClass(LiveFollowMode, LiveFollowMode.TypeName);
//# sourceMappingURL=LiveFollowMode.js.map