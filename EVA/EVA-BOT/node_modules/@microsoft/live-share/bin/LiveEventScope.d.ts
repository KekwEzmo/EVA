/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
import { IErrorEvent, ITelemetryLogger } from "@fluidframework/common-definitions";
import { TypedEventEmitter } from "@fluidframework/common-utils";
import { IInboundSignalMessage } from "@fluidframework/runtime-definitions";
import { ILiveEvent, UserMeetingRole } from "./interfaces";
import { LiveShareRuntime } from "./LiveShareRuntime";
/**
 * Live event callback.
 * @template TEvent Type of event being sent/received.
 * @param evt The event that was sent/received.
 * @param local If true the `evt` is an event that was sent.
 */
export type LiveEventListener<TEvent> = (evt: ILiveEvent<TEvent>, local: boolean) => void;
/**
 * Duck type of something that provides the expected signalling functionality:
 * A way to verify we can signal, a way to send a signal, and a way to listen for incoming signals
 */
export interface IRuntimeSignaler {
    readonly clientId: string | undefined;
    readonly connected: boolean;
    readonly logger: ITelemetryLogger;
    on(event: "connected", listener: (clientId: string) => void): this;
    off(event: "connected", listener: (clientId: string) => void): this;
    on(event: "signal", listener: (message: IInboundSignalMessage, local: boolean) => void): this;
    submitSignal(type: string, content: any): void;
}
/**
 * Object responsible for sending and receiving live share events.
 *
 * @remarks
 * Live objects send and receive events using an event scope. Event scopes can be restricted
 * to only receive events from clients with specific roles. Any events that are received from
 * clients without an allowed role type will be ignored.
 *
 * Event scopes are isolated on a per Fluid object basis. That means that two different Fluid
 * objects using the same event names don't have to worry about collisions.  Two event scopes
 * within the same Fluid object, however, don't have any isolation. You can use multiple event
 * scopes within the same FLuid object, you just need to be careful that they send different
 * events.
 */
export declare class LiveEventScope extends TypedEventEmitter<IErrorEvent> {
    private _liveRuntime;
    private readonly emitter;
    private readonly _runtime;
    private _allowedRoles;
    /**
     * Only throw role validation failed errors for events that are associated with this scope.
     * Useful for dataObjects that use multiple scopes, like LiveMediaSession.
     */
    private throwForEvents;
    /**
     * Creates a new `LiveEventScope` instance.
     * @param runtime A Fluid objects runtime instance, typically `this.runtime`.
     * @param allowedRoles Optional. List of roles allowed to send events using this scope.
     * You should use a second scope if you need mixed permission support.
     */
    constructor(runtime: IRuntimeSignaler, _liveRuntime: LiveShareRuntime, allowedRoles?: UserMeetingRole[]);
    /**
     * List of roles allowed to send events through this scope.
     */
    get allowedRoles(): UserMeetingRole[];
    set allowedRoles(values: UserMeetingRole[]);
    /**
     * The runtimes current client ID. This will be `undefined` if the client is disconnected.
     */
    get clientId(): string | undefined;
    /**
     * Registers a listener for a named event.
     * @template TEvent Type of event to listen for.
     * @param eventName Name of event to listen for.
     * @param listener Function to call when the named event is sent or received.
     */
    onEvent<TEvent>(eventName: string, listener: LiveEventListener<TEvent>): this;
    /**
     * Un-registers a listener for a named event.
     * @template TEvent Type of event being listened for.
     * @param eventName Name of event to un-register.
     * @param listener Function that was originally passed to `onEvent()`.
     */
    offEvent<TEvent>(eventName: string, listener: LiveEventListener<TEvent>): this;
    /**
     * Sends an event to other event scope instances for the Fluid object.
     * @template TEvent Type of event to send.
     * @param eventName Name of the event to send.
     * @param evt Optional. Partial event object to send. The `ILiveEvent.name`,
     * `ILiveEvent.timestamp`, and `ILiveEvent.clientId`
     * fields will be automatically populated prior to sending.
     * @returns The full event, including `ILiveEvent.name`,
     * `ILiveEvent.timestamp`, and `ILiveEvent.clientId` fields if known.
     */
    sendEvent<TEvent>(eventName: string, evt: TEvent): Promise<ILiveEvent<TEvent>>;
    private waitUntilConnected;
}
//# sourceMappingURL=LiveEventScope.d.ts.map