"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveDataObject = void 0;
const aqueduct_1 = require("@fluidframework/aqueduct");
const common_utils_1 = require("@fluidframework/common-utils");
const interfaces_1 = require("./interfaces");
const internals_1 = require("./internals");
/**
 * Extends Fluid's DataObject class. Intended for use with Live Share custom DDS's that rely on a `ILiveShareHost`.
 */
class LiveDataObject extends aqueduct_1.DataObject {
    /**
     * @internal
     * `LiveShareRuntime` instance
     * @remarks
     * You should usually not set this value to a DDS after calling `.initialize()`, but there is nothing preventing it.
     */
    get liveRuntime() {
        (0, common_utils_1.assert)(this._liveRuntime !== null, "LiveShareRuntime not initialized. Ensure your Fluid `ContainerSchema` was first wrapped inside of `getLiveShareSchema`, or use `.joinContainer()` in `LiveShareClient`.");
        return this._liveRuntime;
    }
    /**
     * Flag that indicates whether initialization has succeeded or not.
     *
     * @remarks
     * This field is true when {@link initializeState} is `succeeded`, or false when {@link initializeState} is any other value.
     */
    get isInitialized() {
        return this.initializeState === interfaces_1.LiveDataObjectInitializeState.succeeded;
    }
    /**
     * The initialization status of the data object.
     *
     * @remarks
     * Used to know whether it is safe to call `.initialize()`
     */
    get initializeState() {
        return this._initializeState;
    }
    set initializeState(value) {
        this._initializeState = value;
    }
    constructor(props) {
        super(props);
        this._initializeState = interfaces_1.LiveDataObjectInitializeState.needed;
        /**
         * @hidden
         */
        this._allowedRoles = [];
        /**
         * @hidden
         */
        this._liveRuntime = null;
    }
    /**
     * Get the client info for a given clientId
     * @param clientId Fluid clientId we are requesting user info for
     * @returns IClientInfo object if the user is known, otherwise it will return undefined
     */
    getClientInfo(clientId) {
        return this.liveRuntime.getClientInfo(clientId);
    }
    /**
     * Waits until connected and gets the most recent clientId
     * @returns clientId
     */
    waitUntilConnected() {
        return (0, internals_1.waitUntilConnected)(this.runtime);
    }
    /**
     * Verify that the user has the required roles
     * @returns boolean true if user has the required roles
     */
    verifyLocalUserRoles() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const clientId = yield this.waitUntilConnected();
            return this.liveRuntime.verifyRolesAllowed(clientId, (_a = this._allowedRoles) !== null && _a !== void 0 ? _a : []);
        });
    }
    /**
     * @hidden
     * Dependency injection setter for `LiveShareRuntime`.
     */
    __dangerouslySetLiveRuntime(value) {
        this._liveRuntime = value;
    }
    /**
     * @hidden
     * Utility function that lets you run a function if successful, or throw a consistent Error if not.
     * @param fnSuccess function to run if user has needed roles
     * @returns TResponse if successful. Should never throw an error.
     */
    onLocalUserAllowed(fnSuccess) {
        return __awaiter(this, void 0, void 0, function* () {
            const valid = yield this.verifyLocalUserRoles();
            if (!valid)
                return;
            fnSuccess();
        });
    }
}
/**
 * @hidden
 */
LiveDataObject.LiveEnabled = true;
exports.LiveDataObject = LiveDataObject;
//# sourceMappingURL=LiveDataObject.js.map