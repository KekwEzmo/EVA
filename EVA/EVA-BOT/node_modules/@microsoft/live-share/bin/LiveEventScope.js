"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveEventScope = void 0;
const events_1 = __importDefault(require("events"));
const common_utils_1 = require("@fluidframework/common-utils");
const internals_1 = require("./internals");
/**
 * Object responsible for sending and receiving live share events.
 *
 * @remarks
 * Live objects send and receive events using an event scope. Event scopes can be restricted
 * to only receive events from clients with specific roles. Any events that are received from
 * clients without an allowed role type will be ignored.
 *
 * Event scopes are isolated on a per Fluid object basis. That means that two different Fluid
 * objects using the same event names don't have to worry about collisions.  Two event scopes
 * within the same Fluid object, however, don't have any isolation. You can use multiple event
 * scopes within the same FLuid object, you just need to be careful that they send different
 * events.
 */
class LiveEventScope extends common_utils_1.TypedEventEmitter {
    /**
     * Creates a new `LiveEventScope` instance.
     * @param runtime A Fluid objects runtime instance, typically `this.runtime`.
     * @param allowedRoles Optional. List of roles allowed to send events using this scope.
     * You should use a second scope if you need mixed permission support.
     */
    constructor(runtime, _liveRuntime, allowedRoles) {
        super();
        this._liveRuntime = _liveRuntime;
        this.emitter = new events_1.default();
        /**
         * Only throw role validation failed errors for events that are associated with this scope.
         * Useful for dataObjects that use multiple scopes, like LiveMediaSession.
         */
        this.throwForEvents = [];
        this._runtime = runtime;
        this._allowedRoles = allowedRoles || [];
        this.emitter.on("error", (error) => {
            this.emit("error", error);
        });
        this._runtime.on("signal", (message, local) => {
            if (!message.clientId || !this._runtime.connected)
                return;
            // We don't trust the clientId in the message content as it could have been tampered
            // with (in fact it could be missing if the message was queued when disconnected.)
            // We'll overwrite the contents clientId with the messages clientId which can't be
            // spoofed.
            const clientId = message.clientId;
            message.content.clientId = clientId;
            // Only call listeners when the runtime is connected and if the signal has an
            // identifiable sender clientId.  The listener is responsible for deciding how
            // it wants to handle local/remote signals
            this._liveRuntime
                .verifyRolesAllowed(clientId, this._allowedRoles)
                .then((value) => {
                if (value) {
                    this.emitter.emit(message.type, message.content, local);
                }
                else if (this.throwForEvents.includes(message.type)) {
                    this._runtime.logger.sendErrorEvent({ eventName: "LiveEvent:invalidRole" }, new Error(`The clientId of "${clientId}" doesn't have a role of ${JSON.stringify(this._allowedRoles)}.`));
                }
            })
                .catch((err) => {
                this._runtime.logger.sendErrorEvent({ eventName: "LiveEvent:invalidRole" }, err);
            });
        });
    }
    /**
     * List of roles allowed to send events through this scope.
     */
    get allowedRoles() {
        return this._allowedRoles;
    }
    set allowedRoles(values) {
        this._allowedRoles = values;
    }
    /**
     * The runtimes current client ID. This will be `undefined` if the client is disconnected.
     */
    get clientId() {
        return this._runtime.clientId;
    }
    /**
     * Registers a listener for a named event.
     * @template TEvent Type of event to listen for.
     * @param eventName Name of event to listen for.
     * @param listener Function to call when the named event is sent or received.
     */
    onEvent(eventName, listener) {
        this.throwForEvents.push(eventName);
        this.emitter.on(eventName, listener);
        return this;
    }
    /**
     * Un-registers a listener for a named event.
     * @template TEvent Type of event being listened for.
     * @param eventName Name of event to un-register.
     * @param listener Function that was originally passed to `onEvent()`.
     */
    offEvent(eventName, listener) {
        this.emitter.off(eventName, listener);
        const removeIndex = this.throwForEvents.indexOf(eventName);
        if (removeIndex >= 0) {
            this.throwForEvents.splice(removeIndex, 1);
        }
        return this;
    }
    /**
     * Sends an event to other event scope instances for the Fluid object.
     * @template TEvent Type of event to send.
     * @param eventName Name of the event to send.
     * @param evt Optional. Partial event object to send. The `ILiveEvent.name`,
     * `ILiveEvent.timestamp`, and `ILiveEvent.clientId`
     * fields will be automatically populated prior to sending.
     * @returns The full event, including `ILiveEvent.name`,
     * `ILiveEvent.timestamp`, and `ILiveEvent.clientId` fields if known.
     */
    sendEvent(eventName, evt) {
        return __awaiter(this, void 0, void 0, function* () {
            const clientId = yield this.waitUntilConnected();
            const isAllowed = yield this._liveRuntime.verifyRolesAllowed(clientId, this._allowedRoles);
            if (!isAllowed) {
                throw new Error(`The local user doesn't have a role of ${JSON.stringify(this._allowedRoles)}.`);
            }
            // Clone passed in event and fill out required props.
            const clone = {
                clientId,
                name: eventName,
                timestamp: this._liveRuntime.getTimestamp(),
                data: evt,
            };
            // Send event
            this._runtime.submitSignal(eventName, clone);
            return clone;
        });
    }
    waitUntilConnected() {
        return (0, internals_1.waitUntilConnected)(this._runtime);
    }
}
exports.LiveEventScope = LiveEventScope;
//# sourceMappingURL=LiveEventScope.js.map