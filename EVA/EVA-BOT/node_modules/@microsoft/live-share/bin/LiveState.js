"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveState = exports.LiveStateEvents = void 0;
const aqueduct_1 = require("@fluidframework/aqueduct");
const common_utils_1 = require("@fluidframework/common-utils");
const interfaces_1 = require("./interfaces");
const internals_1 = require("./internals");
const LiveTelemetryLogger_1 = require("./LiveTelemetryLogger");
const LiveEvent_1 = require("./LiveEvent");
const LiveObjectSynchronizer_1 = require("./LiveObjectSynchronizer");
const DynamicObjectRegistry_1 = require("./DynamicObjectRegistry");
const LiveDataObject_1 = require("./LiveDataObject");
/**
 * Events supported by [LiveState` object.
 */
var LiveStateEvents;
(function (LiveStateEvents) {
    /**
     * The objects state has changed.
     */
    LiveStateEvents["stateChanged"] = "stateChanged";
})(LiveStateEvents = exports.LiveStateEvents || (exports.LiveStateEvents = {}));
/**
 * Live fluid object that synchronizes a named state and optional data value across clients.
 *
 * @remarks
 * The primary benefit of using the `LiveState` object in a Teams meeting, versus something
 * like a `SharedMap`, is that you can restrict the roles of who's allowed to perform state
 * changes.
 * @template TState Optional data object that's synchronized with the state.
 */
class LiveState extends LiveDataObject_1.LiveDataObject {
    /**
     * The current state.
     */
    get state() {
        return this.latestEvent.data;
    }
    /**
     * Initialize the object to begin sending/receiving state updates through this DDS.
     *
     * @param initialState Initial state value
     * @param allowedRoles Optional. List of roles allowed to make state changes.
     *
     * @returns a void promise that resolves once complete
     *
     * @throws error when `.initialize()` has already been called for this class instance.
     * @throws fatal error when `.initialize()` has already been called for an object of same id but with a different class instance.
     * This is most common when using dynamic objects through Fluid.
     */
    initialize(initialState, allowedRoles) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.needed) {
                throw new Error(`LiveState already started.`);
            }
            // This error should not happen due to `initializeState` enum, but if it is somehow defined at this point, errors will occur.
            if (this._synchronizer) {
                throw new Error(`LiveState: _synchronizer already set, which is an unexpected error. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            // Update initialize state as pending
            this.initializeState = interfaces_1.LiveDataObjectInitializeState.pending;
            this._logger = new LiveTelemetryLogger_1.LiveTelemetryLogger(this.runtime, this.liveRuntime);
            // Set initial state
            this.latestEvent = {
                clientId: "",
                name: "ChangeState",
                timestamp: 0,
                data: initialState,
            };
            // Save off allowed roles
            this._allowedRoles = allowedRoles || [];
            // Create object synchronizer
            this._synchronizer = new LiveObjectSynchronizer_1.LiveObjectSynchronizer(this.id, this.runtime, this.liveRuntime);
            try {
                yield this._synchronizer.start(initialState, (evt, sender, local) => __awaiter(this, void 0, void 0, function* () {
                    // Check for state change.
                    // If it was valid, this will override the local user's previous value.
                    return yield this.onReceivedStateEvent(evt, sender, local);
                }), (connecting) => __awaiter(this, void 0, void 0, function* () {
                    if (connecting)
                        return true;
                    // If user has eligible roles, allow the update to be sent
                    try {
                        return yield this.verifyLocalUserRoles();
                    }
                    catch (_a) {
                        return false;
                    }
                }));
            }
            catch (error) {
                // Update initialize state as fatal error
                this.initializeState = interfaces_1.LiveDataObjectInitializeState.fatalError;
                throw error;
            }
            // Update initialize state as succeeded
            this.initializeState = interfaces_1.LiveDataObjectInitializeState.succeeded;
        });
    }
    /**
     * Disposes of the object when its container is disposed of.
     */
    dispose() {
        super.dispose();
        if (this._synchronizer) {
            this._synchronizer.dispose();
        }
    }
    /**
     * Set a new state value
     *
     * @param state New state value.
     *
     * @returns a void promise that resolves once the set event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    set(state) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveState: not initialized prior to calling \`.set()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            // Broadcast state change
            const clone = (0, internals_1.cloneValue)(state);
            const evt = yield this._synchronizer.sendEvent(clone);
            // Update local state immediately
            // - The _stateUpdatedEvent won't be triggered until the state change is actually sent. If
            //   the client is disconnected this could be several seconds later.
            this.updateState(evt, true);
        });
    }
    /**
     * The current state.
     */
    get latestEvent() {
        (0, common_utils_1.assert)(this._latestEvent !== undefined, "LiveState is not initialized");
        return this._latestEvent;
    }
    /**
     * The current state.
     */
    set latestEvent(value) {
        this._latestEvent = value;
    }
    // Returns true if the remote state was applied successfully
    onReceivedStateEvent(evt, sender, local) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const allowed = yield this.liveRuntime.verifyRolesAllowed(sender, this._allowedRoles);
                // Ensure that state is allowed, newer, and not the initial state.
                if (!allowed || !LiveEvent_1.LiveEvent.isNewer(this.latestEvent, evt))
                    return false;
                if (JSON.stringify(this.latestEvent.data) ===
                    JSON.stringify(evt.data))
                    return false;
                this.updateState(evt, local);
                return true;
            }
            catch (err) {
                (_a = this._logger) === null || _a === void 0 ? void 0 : _a.sendErrorEvent(internals_1.TelemetryEvents.LiveState.RoleVerificationError, err);
                return false;
            }
        });
    }
    updateState(evt, local) {
        var _a;
        const oldState = this.latestEvent.data;
        const newState = evt.data;
        this.latestEvent = evt;
        this.emit(LiveStateEvents.stateChanged, (0, internals_1.cloneValue)(evt.data), local, evt.clientId, evt.timestamp);
        (_a = this._logger) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(internals_1.TelemetryEvents.LiveState.StateChanged, null, {
            oldState: JSON.stringify(oldState),
            newState: JSON.stringify(newState),
        });
    }
}
/**
 * The objects fluid type/name.
 */
LiveState.TypeName = `@microsoft/live-share:LiveState`;
/**
 * The objects fluid type factory.
 */
LiveState.factory = new aqueduct_1.DataObjectFactory(LiveState.TypeName, LiveState, [], {});
exports.LiveState = LiveState;
/**
 * Register `LiveState` as an available `LoadableObjectClass` for use in packages that support dynamic object loading, such as `@microsoft/live-share-turbo`.
 */
DynamicObjectRegistry_1.DynamicObjectRegistry.registerObjectClass(LiveState, LiveState.TypeName);
//# sourceMappingURL=LiveState.js.map