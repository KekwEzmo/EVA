"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LivePresenceUser = exports.PresenceState = void 0;
const LiveEvent_1 = require("./LiveEvent");
const internals_1 = require("./internals");
const LivePresenceConnection_1 = require("./LivePresenceConnection");
/**
 * List of possible presence states.
 */
var PresenceState;
(function (PresenceState) {
    /**
     * The user is online. Default state while user has at least one client connected.
     */
    PresenceState["online"] = "online";
    /**
     * The user is away. Applications can set this state based on the users activity.
     */
    PresenceState["away"] = "away";
    /**
     * The user is offline. Automatically set for users after their client has stopped sending
     * updates for a period of time.
     */
    PresenceState["offline"] = "offline";
})(PresenceState = exports.PresenceState || (exports.PresenceState = {}));
/**
 * A user that presence is being tracked for.
 */
class LivePresenceUser {
    /**
     * @hidden
     */
    constructor(_clientInfo, _evt, _expirationPeriod, _liveRuntime, _constructedFromLocalEvent) {
        this._clientInfo = _clientInfo;
        this._evt = _evt;
        this._expirationPeriod = _expirationPeriod;
        this._liveRuntime = _liveRuntime;
        this._connections = new Map();
        this._isLocalUser = false;
        this.updateClients(this._evt, _constructedFromLocalEvent);
        this._lastUpdateTime = this._liveRuntime.getTimestamp();
    }
    /**
     * If `true` the user is the local user.
     */
    get isLocalUser() {
        return this._isLocalUser;
    }
    /**
     * ID of the user. Can be undefined when first initialized.
     */
    get userId() {
        return this._clientInfo.userId;
    }
    get displayName() {
        return this._clientInfo.displayName;
    }
    /**
     * Users current state.
     *
     * @remarks
     * This is automatically set to `PresenceState.offline` if the users client hasn't sent updates
     * for a period of time.
     */
    get state() {
        return this.hasExpired() ? PresenceState.offline : this._evt.data.state;
    }
    /**
     * Optional data shared by the user. Returns data from connection with most recent event.
     * Client connection specific data is available from each connection.
     */
    get data() {
        return (0, internals_1.cloneValue)(this._evt.data.data);
    }
    /**
     * Returns the user's meeting roles.
     */
    get roles() {
        return this._clientInfo.roles;
    }
    /**
     * Returns the user's connections.
     */
    getConnections(filter) {
        const list = [];
        this._connections.forEach((connection) => {
            // Ensure connection matches filter
            if (filter == undefined || connection.state == filter) {
                list.push(connection);
            }
        });
        return list;
    }
    getConnection(clientId) {
        return this._connections.get(clientId);
    }
    /**
     * Returns true if the presence object is from the specified client.
     * @param clientId The ID of the client to lookup.
     */
    isFromClient(clientId) {
        return this._connections.get(clientId) !== undefined;
    }
    /**
     * @hidden
     */
    updateReceived(evt, info, localEvent) {
        const remoteUserConvertedToLocal = this.updateClients(evt, localEvent);
        const currentEvent = this._evt;
        const currentClientInfo = this._clientInfo;
        if (LiveEvent_1.LiveEvent.isNewer(currentEvent, evt)) {
            // Save updated event
            this._evt = evt;
            this._clientInfo = info;
            this._lastUpdateTime = this._liveRuntime.getTimestamp();
            // Has anything changed?
            return (remoteUserConvertedToLocal ||
                evt.data.state != currentEvent.data.state ||
                JSON.stringify(info) != JSON.stringify(currentClientInfo) ||
                JSON.stringify(evt.data.data) !=
                    JSON.stringify(currentEvent.data.data));
        }
        return remoteUserConvertedToLocal;
    }
    /**
     * @hidden
     */
    set expirationPeriod(value) {
        this._expirationPeriod = value;
        this._connections.forEach((connection) => {
            connection.expirationPeriod = value;
        });
    }
    hasExpired() {
        const now = this._liveRuntime.getTimestamp();
        const elapsed = now - this._lastUpdateTime;
        return (!this._isLocalUser && elapsed > this._expirationPeriod.milliseconds);
    }
    // returns true if localUser set to true for the first time
    updateClients(evt, localEvent) {
        // The user can be logged into multiple clients
        const connection = this._connections.get(evt.clientId);
        if (connection) {
            connection.updateConnection(evt);
            return false;
        }
        else {
            this._connections.set(evt.clientId, new LivePresenceConnection_1.LivePresenceConnection(evt, localEvent, this._expirationPeriod, this._liveRuntime));
            if (localEvent && !this._isLocalUser) {
                // local user may have received event from non local connection first,
                // resulting in local user being false, set to true
                this._isLocalUser = localEvent;
                return true;
            }
            return false;
        }
    }
}
exports.LivePresenceUser = LivePresenceUser;
//# sourceMappingURL=LivePresenceUser.js.map