import { DataObject, DataObjectTypes, IDataObjectProps } from "@fluidframework/aqueduct";
import { LiveShareRuntime } from "./LiveShareRuntime";
import { IClientInfo, LiveDataObjectInitializeState, UserMeetingRole } from "./interfaces";
/**
 * Extends Fluid's DataObject class. Intended for use with Live Share custom DDS's that rely on a `ILiveShareHost`.
 */
export declare abstract class LiveDataObject<I extends DataObjectTypes = DataObjectTypes> extends DataObject<I> {
    /**
     * @hidden
     */
    static LiveEnabled: boolean;
    private _initializeState;
    /**
     * @hidden
     */
    protected _allowedRoles: UserMeetingRole[];
    /**
     * @hidden
     */
    private _liveRuntime;
    /**
     * @internal
     * `LiveShareRuntime` instance
     * @remarks
     * You should usually not set this value to a DDS after calling `.initialize()`, but there is nothing preventing it.
     */
    protected get liveRuntime(): LiveShareRuntime;
    /**
     * Flag that indicates whether initialization has succeeded or not.
     *
     * @remarks
     * This field is true when {@link initializeState} is `succeeded`, or false when {@link initializeState} is any other value.
     */
    get isInitialized(): boolean;
    /**
     * The initialization status of the data object.
     *
     * @remarks
     * Used to know whether it is safe to call `.initialize()`
     */
    get initializeState(): LiveDataObjectInitializeState;
    protected set initializeState(value: LiveDataObjectInitializeState);
    constructor(props: IDataObjectProps<I>);
    /**
     * Get the client info for a given clientId
     * @param clientId Fluid clientId we are requesting user info for
     * @returns IClientInfo object if the user is known, otherwise it will return undefined
     */
    getClientInfo(clientId: string): Promise<IClientInfo | undefined>;
    /**
     * Waits until connected and gets the most recent clientId
     * @returns clientId
     */
    protected waitUntilConnected(): Promise<string>;
    /**
     * Verify that the user has the required roles
     * @returns boolean true if user has the required roles
     */
    protected verifyLocalUserRoles(): Promise<boolean>;
    /**
     * @hidden
     * Dependency injection setter for `LiveShareRuntime`.
     */
    __dangerouslySetLiveRuntime(value: LiveShareRuntime): void;
    /**
     * @hidden
     * Utility function that lets you run a function if successful, or throw a consistent Error if not.
     * @param fnSuccess function to run if user has needed roles
     * @returns TResponse if successful. Should never throw an error.
     */
    onLocalUserAllowed(fnSuccess: () => void): Promise<void>;
}
//# sourceMappingURL=LiveDataObject.d.ts.map