import { LiveDataObject } from "./LiveDataObject";
import { ILivePresenceEvents } from "./LivePresence";
import { DataObjectFactory } from "@fluidframework/aqueduct";
import { UserMeetingRole } from "./interfaces";
import { LivePresenceUser, PresenceState } from "./LivePresenceUser";
/**
 * @beta
 *
 * Events supported by `LiveFollowMode` object.
 */
export declare enum LiveFollowModeEvents {
    /**
     * The follow mode state changed.
     */
    stateChanged = "stateChanged",
    /**
     * A user's presence state changed.
     */
    presenceChanged = "presenceChanged"
}
/**
 * @beta
 *
 * Event typings for `LiveFollowMode` class.
 * @template TData Type of data object to share with clients.
 */
export interface ILiveFollowModeEvents<TData = any> extends ILivePresenceEvents<IFollowModePresenceUserData<TData>> {
    /**
     * The presence information for the local or a remote user has changed.
     * @param event Name of event.
     * @param listener Function called when event is triggered.
     * @param listener.state Follow mode state.
     * @param listener.local If true the local client initiated this state change.
     * @param listener.clientId The client ID for the user that triggered this message.
     */
    (event: "stateChanged", listener: (state: IFollowModeState<TData>, local: boolean, clientId: string) => void): any;
}
/**
 * @beta
 *
 * The follow mode type.
 *
 * @remarks
 * Determines which user's `stateValue` is being referenced by `LiveFollowMode`'s `state.value` field.
 * Use to tell the user the current state of follow mode (e.g., "You are actively presenting").
 * Use to determine any relevant button(s) to show to the user (e.g., "Stop presenting").
 */
export declare enum FollowModeType {
    /**
     * Local user is not following anyone, there is no presenter, and nobody is following them.
     */
    local = "local",
    /**
     * Local user is being followed by other remote users.
     */
    activeFollowers = "activeFollowers",
    /**
     * Local user is actively presenting to other users.
     */
    activePresenter = "activePresenter",
    /**
     * Local user is following the presenter and is in sync.
     */
    followPresenter = "followPresenter",
    /**
     * The local user is suspended from the remote active presenter.
     */
    suspendFollowPresenter = "suspendFollowPresenter",
    /**
     * Local user is following a specific user and is in sync.
     */
    followUser = "followUser",
    /**
     * The local user is suspended from following a specific user.
     */
    suspendFollowUser = "suspendFollowUser"
}
/**
 * @beta
 *
 * Information about the state of the local user's follow mode.
 *
 * @remarks
 * This includes information such as whether there is a presenting user and which user's state is relevant to the local user.
 */
export interface IFollowModeState<TData = any> {
    /**
     * The follow mode type for the local user.
     *
     * @remarks
     * Determines which user's {@link IFollowModePresenceUserData["stateValue"]} to use for {@link value}.
     * Calculated using a combination of different conditions, such as whether there is an active presenter.
     */
    type: FollowModeType;
    /**
     * The custom value the app should use locally to reflect the follow state.
     *
     * @remarks
     * The relevant user's {@link IFollowModePresenceUserData["stateValue"]}, as determined by {@link type}.
     * For example, if `FollowModeType` is `activePresenter`, this value will be the actively presenting user's `stateValue`.
     */
    value: TData;
    /**
     * The userId of the user that the user is following.
     * This value can be either the presenting user or a specific user the local user is following.
     *
     * @remarks
     * Is a string when {@link type} is `followPresenter`, `suspendFollowPresenter`, `followUser`, or `suspendFollowUser`.
     * Is undefined when {@link type} is `local` or `activePresenter`.
     * Presenting takes precedence over following a specific user.
     */
    followingUserId: string;
    /**
     * Number of other non-local users following along with this current state value
     */
    otherUsersCount: number;
    /**
     * Indicates that is true when the {@link value} is referencing the local user's {@link IFollowModePresenceUserData["stateValue"]}.
     *
     * @remarks
     * When true, {@link followingUserId} may not be the local user's id when {@link type} is `suspendFollowUser` or `suspendFollowPresenter`.
     */
    isLocalValue: boolean;
}
/**
 * @beta
 *
 * The presence data for a user's personal follow mode state.
 */
export interface IFollowModePresenceUserData<TData = any> {
    /**
     * User's personal state
     */
    stateValue: TData;
    /**
     * The user that this user is following.
     *
     * @remarks
     * This will be ignored when `LiveFollowMode["presentingUserIdState"]` is set.
     */
    followingUserId: string | undefined;
}
/**
 * @beta
 *
 * Convenience type for a LivePresenceUser in LiveFollowMode
 */
export type FollowModePresenceUser<TData = any> = LivePresenceUser<IFollowModePresenceUserData<TData>>;
/**
 * @beta
 *
 * Live object that allows users to present and/or follow other users.
 * Provides a {@link state} value, which reflects the relevant value to reference (e.g., the presenting user's state value).
 *
 * @template TData Type of data value to share with clients for each user (e.g., the user's camera position in a 3D scene).
 */
export declare class LiveFollowMode<TData = any> extends LiveDataObject<{
    Events: ILiveFollowModeEvents<TData>;
}> {
    private _logger?;
    /**
     * The synchronized userId of a user that is in control of presenting
     */
    private _presentingUserIdState?;
    /**
     * Flag for whether the local user is out of sync with the person they are following.
     * Defaults to false, even if the user is not following anyone.
     */
    private _suspended;
    /**
     * The `LivePresence` instance for tracking each user's state
     */
    private _presence?;
    /**
     * The most recent emitted follow state
     */
    private _recentState?;
    /**
     * The objects fluid type/name.
     */
    static readonly TypeName = "@microsoft/live-share:LiveFollowMode";
    /**
     * The objects fluid type factory.
     */
    static readonly factory: DataObjectFactory<LiveFollowMode<any>, import("@fluidframework/aqueduct").DataObjectTypes>;
    /**
     * Gets the current follow mode state.
     *
     * @remarks
     * Value is {@link IFollowModeState} when follow mode state is ready to access, and undefined when pending.
     */
    get state(): IFollowModeState<TData> | undefined;
    /**
     * Local LivePresenceUser.
     * Can be undefined before LiveFollowMode is initialized.
     */
    get localUser(): FollowModePresenceUser<TData> | undefined;
    /**
     * Convenience getter to get the `_dynamicObjectsCollection` without having to check for undefined, since this will
     * never be undefined after `initializingFirstTime`.
     */
    private get presentingUserIdState();
    /**
     * Convenience getter to get the `_dynamicObjectsCollection` without having to check for undefined, since this will
     * never be undefined after `initializingFirstTime`.
     */
    private get presence();
    /**
     * Initialize the object to begin sending/receiving state updates through this DDS.
     *
     * @param initialState Initial state value
     * @param allowedRoles Optional. List of roles allowed to make state changes.
     *
     * @returns a void promise that resolves once complete
     *
     * @throws error when `.initialize()` has already been called for this class instance.
     * @throws fatal error when `.initialize()` has already been called for an object of same id but with a different class instance.
     * This is most common when using dynamic objects through Fluid.
     */
    initialize(initialState: TData, allowedRoles?: UserMeetingRole[]): Promise<void>;
    /**
     * Broadcast a new custom data value for the local user's current state.
     *
     * @remarks
     * Each user has their own state value, though it will differ from what is shown in {@link state} depending on the value of {@link FollowModeType}.
     * Will cause the user to become out of sync if another user is presenting or the local user is following another user.
     * To see each user's state, use the {@link getUsers} API, or listen to "presenceChanged" updates.
     *
     * @param newValue the state value for the local user's presence record.
     *
     * @returns a void promise that resolves once the update event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     */
    update(newValue: TData): Promise<void>;
    /**
     * Start presenting the local user's state.
     *
     * @remarks
     * If another user is already presenting, the local user will take control of presenting from the previous presenter.
     * To update the local user's state that both the local and remote users will reference, use the {@link update} function.
     * This API will override any `followingUserId` value that was set through {@link followUser} until presenting has stopped.
     * To stop presenting, use the {@link stopPresenting} API.
     *
     * @returns a void promise that resolves once the event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user is already the presenter.
     * @throws error if the local user does not have the required roles to present.
     */
    startPresenting(): Promise<void>;
    /**
     * Stop presenting the presenting user's current state.
     *
     * @remarks
     * This API allows any user with valid roles to cancel presenting, though we generally recommend only allowing the active presenter to do so.
     * To start presenting, use the {@link startPresenting} API.
     *
     * @returns a void promise that resolves once the event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles to stop presenting.
     */
    stopPresenting(): Promise<void>;
    /**
     * Temporarily stop following presenter/follower.
     *
     * @returns a void promise once the operation succeeds.
     *
     * @throws error if initialization has not yet succeeded.
     */
    beginSuspension(): Promise<void>;
    /**
     * Resume following presenter/follower.
     *
     * @returns a void promise once the operation succeeds.
     *
     * @throws error if initialization has not yet succeeded.
     */
    endSuspension(): Promise<void>;
    /**
     * Follows another user in the session.
     *
     * @remarks
     * If another user is presenting, {@link state} will not reflect following this user until there is no longer a presenter.
     *
     * @param userId the userId for the user to follow.
     *
     * @returns a void promise that resolves once the event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if attempting to follow a user that is not recognized by this object's `LivePresence` instance.
     * @throws error if the `userId` provided is equal to the local user's `userId`.
     */
    followUser(userId: string): Promise<void>;
    /**
     * Stop following the currently following user.
     *
     * @returns a void promise that resolves once the event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the user is not already following another user.
     */
    stopFollowing(): Promise<void>;
    /**
     * Returns a snapshot of the current list of presence objects being tracked.
     * @param filter Optional. Presence state to filter enumeration to.
     * @returns Array of presence objects.
     */
    getUsers(filter?: PresenceState): FollowModePresenceUser<TData>[];
    /**
     * Returns the current presence info for a specific user.
     * @param userId The ID of the user to retrieve.
     * @returns The current presence information for the user if they've connected to the space.
     */
    getUser(userId: string): FollowModePresenceUser<TData> | undefined;
    /**
     * Returns the current presence info for a specific client ID.
     * @param clientId The ID of the client to retrieve.
     * @returns The current presence information for the client if they've connected to the space.
     */
    getUserForClient(clientId: string): FollowModePresenceUser<TData> | undefined;
    /**
     * Get the users that are following a given userId.
     *
     * @param userId the userId of the person being followed.
     * @param stateFilter the presence state to filter results by.
     */
    getUserFollowers(userId: string, stateFilter?: PresenceState): FollowModePresenceUser<TData>[];
    /**
     * Disposes of the object when its container is disposed of.
     */
    dispose(): void;
    /**
     * initializingFirstTime is run only once by the first client to create the DataObject. Here we use it to
     * initialize the state of the DataObject.
     */
    protected initializingFirstTime(): Promise<void>;
    /**
     * hasInitialized is run by each client as they load the DataObject.  Here we use it to initialize the
     * task manager, listen for task assignments, and listen for changes to the dynamic objects map.
     */
    protected hasInitialized(): Promise<void>;
    /**
     * Checks if the state has changed since we last checked, and if so, emits change.
     */
    private handlePotentialStateChange;
}
//# sourceMappingURL=LiveFollowMode.d.ts.map