"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveTimer = exports.LiveTimerEvents = void 0;
const aqueduct_1 = require("@fluidframework/aqueduct");
const LiveObjectSynchronizer_1 = require("./LiveObjectSynchronizer");
const interfaces_1 = require("./interfaces");
const LiveEvent_1 = require("./LiveEvent");
const DynamicObjectRegistry_1 = require("./DynamicObjectRegistry");
const LiveDataObject_1 = require("./LiveDataObject");
/**
 * Events supported by `LiveTimer` object.
 */
var LiveTimerEvents;
(function (LiveTimerEvents) {
    /**
     * Timer has started
     */
    LiveTimerEvents["started"] = "started";
    /**
     * Paused timer has resumed
     */
    LiveTimerEvents["played"] = "played";
    /**
     * Playing timer has paused
     */
    LiveTimerEvents["paused"] = "paused";
    /**
     * Timer has finished
     */
    LiveTimerEvents["finished"] = "finished";
    /**
     * Timer has progressed
     */
    LiveTimerEvents["onTick"] = "onTick";
})(LiveTimerEvents = exports.LiveTimerEvents || (exports.LiveTimerEvents = {}));
class LiveTimer extends LiveDataObject_1.LiveDataObject {
    constructor() {
        super(...arguments);
        this._currentConfig = {
            clientId: "",
            timestamp: 0,
            data: {
                duration: 0,
                position: 0,
                running: false,
            },
        };
        this._defaultTickRate = 20;
        this._tickRate = this._defaultTickRate;
    }
    /**
     * Tick rate for timer in milliseconds. The default tick rate is 20 milliseconds
     *
     * @remarks
     * Tick rate is used to evaluate how often onTick callback is called.
     * A high tick rate can also result in the started, played, paused, and finished
     * callbacks being called slightly later.
     *
     * If the tick rate is the default tick rate or lower, timer will tick
     * at the framerate of the browser.
     */
    get tickRate() {
        return this._tickRate;
    }
    set tickRate(value) {
        this._tickRate = value;
    }
    /**
     * Initialize the object to begin sending/receiving timer updates through this DDS.
     *
     * @param allowedRoles Optional. List of roles allowed to make state changes.
     *
     * @returns a void promise that resolves once complete.
     *
     * @throws error when `.initialize()` has already been called for this class instance.
     * @throws fatal error when `.initialize()` has already been called for an object of same id but with a different class instance.
     * This is most common when using dynamic objects through Fluid.
     */
    initialize(allowedRoles) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.needed) {
                throw new Error(`LiveTimer already started.`);
            }
            // This error should not happen due to `initializeState` enum, but if it is somehow defined at this point, errors will occur.
            if (this._synchronizer) {
                throw new Error(`LiveTimer: _synchronizer already set, which is an unexpected error. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            // Update initialize state as pending
            this.initializeState = interfaces_1.LiveDataObjectInitializeState.pending;
            // Save off allowed roles
            this._allowedRoles = allowedRoles || [];
            // Create object synchronizer
            this._synchronizer = new LiveObjectSynchronizer_1.LiveObjectSynchronizer(this.id, this.runtime, this.liveRuntime);
            try {
                yield this._synchronizer.start(this._currentConfig.data, (state, sender) => __awaiter(this, void 0, void 0, function* () {
                    // Check for state change.
                    // If it was valid, this will override the local user's previous value.
                    return yield this.remoteConfigReceived(state, sender);
                }), (connecting) => __awaiter(this, void 0, void 0, function* () {
                    if (connecting)
                        return true;
                    // If user has eligible roles, allow the update to be sent
                    try {
                        return yield this.verifyLocalUserRoles();
                    }
                    catch (_a) {
                        return false;
                    }
                }));
            }
            catch (error) {
                // Update initialize state as fatal error
                this.initializeState = interfaces_1.LiveDataObjectInitializeState.fatalError;
                throw error;
            }
            // Update initialize state as succeeded
            this.initializeState = interfaces_1.LiveDataObjectInitializeState.succeeded;
        });
    }
    /**
     * Disposes of the object when its container is disposed of.
     */
    dispose() {
        super.dispose();
        if (this._synchronizer) {
            this._synchronizer.dispose();
        }
    }
    /**
     * Starts the timer with a specified duration.
     *
     * @remarks
     * Starting an already started timer will restart the timer with a new duration.
     *
     * @param duration in Milliseconds
     *
     * @returns a void promise that resolves once the start event has been sent to the server
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    start(duration) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveTimer: not initialized prior to calling \`.start()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            yield this.playInternal(duration, 0);
        });
    }
    /**
     * Resumes the timer.
     *
     * @remarks
     * Playing an already playing timer does nothing.
     *
     * @returns a void promise that resolves once the play event has been sent to the server
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    play() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveTimer: not initialized prior to calling \`.play()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            if (!this._currentConfig.data.running &&
                this._currentConfig.data.position <
                    this._currentConfig.data.duration) {
                yield this.playInternal(this._currentConfig.data.duration, this._currentConfig.data.position);
            }
        });
    }
    playInternal(duration, position) {
        return __awaiter(this, void 0, void 0, function* () {
            // Broadcast state change
            const event = {
                timestamp: this.liveRuntime.getTimestamp(),
                clientId: yield this.waitUntilConnected(),
                data: {
                    duration: duration,
                    position: position,
                    running: true,
                },
            };
            // Update local state immediately
            yield this.updateConfig(event, true);
        });
    }
    /**
     * Pauses the timer.
     *
     * @remarks
     * Pausing an already paused timer does nothing.
     *
     * @returns a void promise that resolves once the pause event has been sent to the server
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    pause() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LiveTimer: not initialized prior to calling \`.pause()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            if (this._currentConfig.data.running) {
                // Broadcast state change
                const currentTime = this.liveRuntime.getTimestamp();
                const event = {
                    timestamp: currentTime,
                    clientId: yield this.waitUntilConnected(),
                    data: {
                        duration: this._currentConfig.data.duration,
                        position: this._currentConfig.data.position +
                            (currentTime - this._currentConfig.timestamp),
                        running: false,
                    },
                };
                // Update local state immediately
                yield this.updateConfig(event, true);
            }
        });
    }
    remoteConfigReceived(config, sender) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const allowed = yield this.liveRuntime.verifyRolesAllowed(sender, this._allowedRoles);
                // Ensure that state is allowed, newer, and not the initial state.
                const currentClientTimestamp = {
                    timestamp: this._currentConfig.timestamp,
                    clientId: this._currentConfig.clientId,
                };
                const isConfigNewer = LiveEvent_1.LiveEvent.isNewer(currentClientTimestamp, config);
                const currentTime = this.liveRuntime.getTimestamp();
                const endTime = this.endTimeFromConfig(config);
                if (allowed &&
                    this._currentConfig.timestamp === 0 &&
                    config.data.running === true &&
                    currentTime >= endTime) {
                    // Since finish config changes are not sent through the Synchronizer only the most recent config before finish is saved.
                    // For clients joining after the the timer has already finished, set the finish config.
                    const finishedBeforeJoinConfig = {
                        timestamp: endTime,
                        clientId: config.clientId,
                        data: {
                            duration: config.data.duration,
                            position: config.data.duration,
                            running: false,
                        },
                    };
                    this.updateConfig(finishedBeforeJoinConfig, false);
                    return true;
                }
                if (JSON.stringify(this._currentConfig.data) ===
                    JSON.stringify(config.data) &&
                    this._currentConfig.timestamp === config.timestamp)
                    return false;
                if (allowed && isConfigNewer) {
                    this.updateConfig(config, false);
                    return true;
                }
                return false;
            }
            catch (err) {
                return false;
            }
        });
    }
    updateConfig(event, local) {
        return __awaiter(this, void 0, void 0, function* () {
            const userExposedConfig = Object.assign({ clientId: event.clientId, configChangedAt: event.timestamp }, event.data);
            this._currentConfig = event;
            if (event.data.position === 0) {
                this.emit(LiveTimerEvents.started, userExposedConfig, local);
            }
            else if (event.data.duration === event.data.position) {
                this.emit(LiveTimerEvents.finished, userExposedConfig);
            }
            else if (event.data.running) {
                this.emit(LiveTimerEvents.played, userExposedConfig, local);
            }
            else {
                this.emit(LiveTimerEvents.paused, userExposedConfig, local);
            }
            if (event.data.running) {
                this.startTicking();
            }
            if (local) {
                return yield this._synchronizer.sendEvent(event.data);
            }
        });
    }
    startTicking() {
        const tickCallback = () => {
            if (this._currentConfig.data.running) {
                const timestamp = this.liveRuntime.getTimestamp();
                const endTime = this.endTimeFromConfig(this._currentConfig);
                if (timestamp >= endTime) {
                    const newConfig = {
                        timestamp: endTime,
                        clientId: this._currentConfig.clientId,
                        data: {
                            duration: this._currentConfig.data.duration,
                            position: this._currentConfig.data.duration,
                            running: false,
                        },
                    };
                    // Set local to false for this config update.
                    // Every client is expected to set the finish config locally for themselves at the same time.
                    // We do not want a bunch of duplicate synchronizer finish events to go out at the exact same time for every client.
                    this.updateConfig(newConfig, false).catch((err) => {
                        console.error(err);
                    });
                }
                else {
                    this.emit(LiveTimerEvents.onTick, endTime - timestamp);
                    this.scheduleAnimationFrame(tickCallback);
                }
            }
        };
        this.scheduleAnimationFrame(tickCallback);
    }
    scheduleAnimationFrame(callback) {
        if (this._tickRate <= this._defaultTickRate &&
            typeof requestAnimationFrame == "function") {
            requestAnimationFrame(callback);
        }
        else {
            setTimeout(callback, this._tickRate);
        }
    }
    endTimeFromConfig(config) {
        return config.timestamp - config.data.position + config.data.duration;
    }
}
/**
 * The objects fluid type/name.
 */
LiveTimer.TypeName = `@microsoft/live-share:LiveTimer`;
/**
 * The objects fluid type factory.
 */
LiveTimer.factory = new aqueduct_1.DataObjectFactory(LiveTimer.TypeName, LiveTimer, [], {});
exports.LiveTimer = LiveTimer;
/**
 * Register `LiveTimer` as an available `LoadableObjectClass` for use in packages that support dynamic object loading, such as `@microsoft/live-share-turbo`.
 */
DynamicObjectRegistry_1.DynamicObjectRegistry.registerObjectClass(LiveTimer, LiveTimer.TypeName);
//# sourceMappingURL=LiveTimer.js.map