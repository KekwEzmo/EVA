"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveShareHostDecorator = void 0;
const BaseHostDecorator_1 = require("./BaseHostDecorator");
const RequestCache_1 = require("./RequestCache");
const type_guards_1 = require("./type-guards");
const utils_1 = require("./utils");
const EXPONENTIAL_BACKOFF_SCHEDULE = [100, 200, 200, 400, 600];
const CACHE_LIFETIME = 4 * 1000;
/**
 * @hidden
 * Live Share Host decorator used to reduce rapid duplicate requests.
 */
class LiveShareHostDecorator extends BaseHostDecorator_1.BaseHostDecorator {
    constructor() {
        super(...arguments);
        this._registerRequestCache = new RequestCache_1.RequestCache(CACHE_LIFETIME);
        this._userInfoRequestCache = new RequestCache_1.RequestCache(CACHE_LIFETIME);
    }
    getClientInfo(clientId, lateFinish, // TODO: delete this and below (not a breaking change to remove, see InternalDontUseGetClientInfoRetryPolyfill)
    retrySchedule) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!clientId) {
                throw new Error(`LiveShareHostDecorator: called getClientInfo() without a clientId`);
            }
            // backwards compat should not use same cache from LiveShareHostDecorator
            const cacheKey = retrySchedule
                ? `${clientId}backwardsCompat`
                : clientId;
            return this._userInfoRequestCache.cacheRequest(cacheKey, () => {
                return (0, utils_1.waitForResult)(() => __awaiter(this, void 0, void 0, function* () {
                    return yield this._host.getClientInfo(clientId);
                }), (result) => {
                    if ((0, type_guards_1.isIClientInfo)(result)) {
                        return {
                            response: result,
                        };
                    }
                    return null;
                }, (error) => {
                    return new Error(`LiveShareHostDecorator: getting client info for a remote client ID for reason: ${(0, type_guards_1.isErrorLike)(error) ? error.message : "unknown"}`);
                }, retrySchedule !== null && retrySchedule !== void 0 ? retrySchedule : EXPONENTIAL_BACKOFF_SCHEDULE, (error) => {
                    // Errors here do not include any timeout errors, so if it is an error from "fakeId", we immediately reject it
                    if (clientId === "fakeId") {
                        return new Error((0, type_guards_1.isErrorLike)(error)
                            ? error.message
                            : "an unknown error occurred");
                    }
                    return null;
                }, lateFinish // TODO: delete (not a breaking change to remove, see InternalDontUseGetClientInfoRetryPolyfill)
                );
            });
        });
    }
    registerClientId(clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._registerRequestCache.cacheRequest(clientId, () => {
                return (0, utils_1.waitForResult)(() => __awaiter(this, void 0, void 0, function* () {
                    return yield this._host.registerClientId(clientId);
                }), (result) => {
                    if ((0, type_guards_1.isClientRolesResponse)(result)) {
                        return {
                            response: result,
                        };
                    }
                    else if ((0, type_guards_1.isMobileWorkaroundRolesResponse)(result)) {
                        return {
                            response: result.userRoles,
                        };
                    }
                    return null;
                }, (reason) => {
                    return new Error(`LiveShareHostDecorator: registering local client ID for reason: ${(0, type_guards_1.isErrorLike)(reason) ? reason.message : "unknown"}`);
                }, EXPONENTIAL_BACKOFF_SCHEDULE);
            });
        });
    }
}
exports.LiveShareHostDecorator = LiveShareHostDecorator;
//# sourceMappingURL=LiveShareHostDecorator.js.map