"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainerSynchronizer = void 0;
const ThrottledEventQueue_1 = require("./ThrottledEventQueue");
const consts_1 = require("./consts");
const utils_1 = require("./utils");
/**
 * @hidden
 */
class ContainerSynchronizer {
    constructor(_runtime, _containerRuntime, _liveRuntime, _objectStore) {
        this._runtime = _runtime;
        this._containerRuntime = _containerRuntime;
        this._liveRuntime = _liveRuntime;
        this._objectStore = _objectStore;
        this._objects = new Map();
        this._throttledEventsQueue = new ThrottledEventQueue_1.ThrottledEventQueue(this);
        this._connectedKeys = [];
        this._refCount = 0;
        this.startListeningForConnected();
    }
    registerObject(id, handlers) {
        var _a;
        if (this._objects.has(id)) {
            throw new Error(`LiveObjectSynchronizer: too many calls to registerObject() for object '${id}'`);
        }
        this._connectedKeys.push(id);
        // Save object ref
        this._objects.set(id, handlers);
        if (this._runtime.clientId &&
            this._runtime.clientId !== this._connectSentForClientId) {
            this.onConnected(this._runtime.clientId);
        }
        // Play back the most recent cached event for each clientId to get the initial remote state
        (_a = this._objectStore.getEventsForObject(id)) === null || _a === void 0 ? void 0 : _a.forEach((event) => {
            this.onReceiveUpdate(id, event, event.clientId === this._runtime.clientId);
        });
        // Start update timer on first ref
        if (this._refCount++ == 0) {
            this.startBackgroundObjectUpdates();
        }
    }
    unregisterObject(id) {
        if (this._objects.has(id)) {
            // Remove object ref
            this._objects.delete(id);
            // Stop update timer on last de-ref
            if (--this._refCount == 0) {
                this.stopBackgroundObjectUpdates();
                return true;
            }
            // Remove id from key lists
            this._connectedKeys = this._connectedKeys.filter((key) => key != id);
        }
        return false;
    }
    /**
     * On send background updates handler
     *
     * @returns void promise once the events were sent (unless skipped)
     */
    onSendBackgroundUpdates() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._liveRuntime.canSendBackgroundUpdates)
                return;
            yield this.sendGroupEvent(this._connectedKeys, consts_1.ObjectSynchronizerEvents.update).catch((err) => console.error(err));
        });
    }
    /**
     * Sends a one-time event for a given object
     * @param objectId the `LiveDataObject` id
     * @param data the date for the event to send
     * @returns the latest events sent, or undefined if there are none
     */
    sendEventForObject(objectId, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const handlers = this._objects.get(objectId);
            if (!handlers) {
                throw new Error("ContainerSynchronizer.sendEventForObject(): cannot send an event for an object that is not registered");
            }
            const canSend = yield handlers.getLocalUserCanSend(false);
            if (!canSend) {
                throw new Error("The local user doesn't meet the app requirements to send a message for this object");
            }
            // We send as a batch update in case we eventually want to support batching/queuing at this layer, and to reuse existing code.
            const updateEvents = yield this.sendEventUpdates({
                [objectId]: {
                    data,
                    timestamp: this._liveRuntime.getTimestamp(),
                },
            }, consts_1.ObjectSynchronizerEvents.update);
            if (!updateEvents) {
                throw new Error("Unable to send an event with empty updates");
            }
            const valueSent = {
                clientId: updateEvents.clientId,
                timestamp: updateEvents.data[objectId].timestamp,
                name: updateEvents.name,
                data: updateEvents.data[objectId].data,
            };
            return valueSent;
        });
    }
    /**
     * Sends a one-time event that is throttled for the purposes of consolidating multiple signals into a single one.
     * @param objectId the `LiveDataObject` id
     * @param data the date for the event to send
     * @returns the latest events sent, or undefined if there are none
     */
    sendThrottledEventForObject(objectId, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const handlers = this._objects.get(objectId);
            if (!handlers) {
                throw new Error("ContainerSynchronizer.sendThrottledEventForObject(): cannot send an event for an object that is not registered");
            }
            const canSend = yield handlers.getLocalUserCanSend(false);
            if (!canSend) {
                throw new Error("The local user doesn't meet the app requirements to send a message for this object");
            }
            return yield this._throttledEventsQueue.sendWithQueue(objectId, {
                data,
                timestamp: this._liveRuntime.getTimestamp(),
            });
        });
    }
    /**
     * @hidden
     * Send a batch of events
     * @param updates updates to send
     * @param evtType type of event
     * @returns event where data is then StateSyncEventContent containing the batched events that were sent.
     */
    sendEventUpdates(updates, evtType) {
        return __awaiter(this, void 0, void 0, function* () {
            const updateKeys = Object.keys(updates);
            // Send event if we have any updates to broadcast
            // - `send` is only set if at least one component returns an update.
            if (updateKeys.length > 0) {
                const content = {
                    clientId: yield this.waitUntilConnected(),
                    data: updates,
                    timestamp: evtType === consts_1.ObjectSynchronizerEvents.connect
                        ? 0 // use zero for connect events because we are sending initial states
                        : this._liveRuntime.getTimestamp(),
                    name: evtType,
                };
                this._containerRuntime.submitSignal(evtType, content);
                return content;
            }
        });
    }
    /**
     * @hidden
     * Do not use this API unless you know what you are doing.
     * Using it incorrectly could cause object synchronizers to stop working.
     * @see LiveShareRuntime.__dangerouslySetContainerRuntime
     */
    __dangerouslySetContainerRuntime(cRuntime) {
        if (this._containerRuntime === cRuntime)
            return;
        this._containerRuntime = cRuntime;
    }
    onConnected(clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (clientId === this._connectSentForClientId)
                return;
            if (this._connectSentForClientId) {
                this._objectStore.clientIdDidChange(this._connectSentForClientId, clientId);
            }
            this._connectSentForClientId = clientId;
            // TODO: this is a fatal error if it doesn't succeed, so we should be careful
            this._liveRuntime.host.registerClientId(clientId).catch((error) => {
                console.error(error);
            });
            try {
                yield this.sendGroupEvent(this._connectedKeys, consts_1.ObjectSynchronizerEvents.connect);
            }
            catch (err) {
                console.error(`LiveObjectSynchronizer: error sending update - ${err.toString()}`);
            }
        });
    }
    sendGroupEvent(keys, evtType) {
        return __awaiter(this, void 0, void 0, function* () {
            // Compose list of updates
            const skipKeys = [];
            const updates = {};
            const localClientId = yield this.waitUntilConnected();
            for (let objIndex = 0; objIndex < keys.length; objIndex++) {
                const objectId = keys[objIndex];
                try {
                    // Ignore components that return undefined
                    const handlers = this._objects.get(objectId);
                    if (handlers &&
                        (yield handlers.getLocalUserCanSend(evtType === consts_1.ObjectSynchronizerEvents.connect))) {
                        const state = this._objectStore.getLatestEventForObjectClient(objectId, localClientId);
                        if (typeof state == "object") {
                            updates[objectId] = {
                                data: state.data,
                                timestamp: handlers.shouldUpdateTimestampPeriodically
                                    ? this._liveRuntime.getTimestamp()
                                    : evtType ===
                                        consts_1.ObjectSynchronizerEvents.connect
                                        ? 0
                                        : state.timestamp,
                            };
                            continue;
                        }
                    }
                }
                catch (err) {
                    console.error(`LiveObjectSynchronizer: error getting an objects state - ${err.toString()}`);
                }
                skipKeys.push(objectId);
            }
            const updateKeys = Object.keys(updates);
            // Send event if we have any updates to broadcast
            // - `send` is only set if at least one component returns an update.
            yield this.sendEventUpdates(updates, evtType);
            return {
                sent: updateKeys,
                skipped: skipKeys,
            };
        });
    }
    /**
     * On received event update
     */
    onReceiveUpdate(objectId, event, local) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this._objects.get(objectId);
            if (!handler)
                return;
            const overwriteForLocal = yield handler.updateState(event, event.clientId, local);
            if (!overwriteForLocal)
                return;
            this._objectStore.updateEventLocallyInStore.bind(this._objectStore)(objectId, Object.assign(Object.assign({}, event), { clientId: yield this.waitUntilConnected() }));
        });
    }
    /**
     * Waits until connected and gets the most recent clientId
     * @returns clientId
     */
    waitUntilConnected() {
        return (0, utils_1.waitUntilConnected)(this._runtime);
    }
    startListeningForConnected() {
        if (this._onBoundConnectedListener) {
            this.stopListeningForConnected();
        }
        this._onBoundConnectedListener = this.onConnected.bind(this);
        this._runtime.on("connected", this._onBoundConnectedListener);
    }
    stopListeningForConnected() {
        if (!this._onBoundConnectedListener)
            return;
        this._runtime.off("connected", this._onBoundConnectedListener);
    }
    startBackgroundObjectUpdates() {
        // Stop existing background updates
        this.stopBackgroundObjectUpdates();
        // Start receiving object updates
        this._onReceiveObjectUpdateListener = this.onReceiveUpdate.bind(this);
        this._objectStore.on(consts_1.ObjectSynchronizerEvents.update, this._onReceiveObjectUpdateListener);
        // Set background updates
        this._onSendUpdatesIntervalCallback =
            this.onSendBackgroundUpdates.bind(this);
        this._hTimer = setInterval(this._onSendUpdatesIntervalCallback, this._liveRuntime.objectManager.updateInterval);
    }
    stopBackgroundObjectUpdates() {
        if (this._hTimer) {
            clearInterval(this._hTimer);
            this._hTimer = undefined;
            this._onSendUpdatesIntervalCallback = undefined;
        }
        if (!this._onReceiveObjectUpdateListener)
            return;
        this._objectStore.off("update", this._onReceiveObjectUpdateListener);
        this._onReceiveObjectUpdateListener = undefined;
    }
}
exports.ContainerSynchronizer = ContainerSynchronizer;
//# sourceMappingURL=ContainerSynchronizer.js.map