/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
import { TypedEventEmitter } from "@fluidframework/common-utils";
import { IRuntimeSignaler } from "../LiveEventScope";
import { LiveShareRuntime } from "../LiveShareRuntime";
import { IContainerRuntimeSignaler, ILiveEvent } from "../interfaces";
import { GetAndUpdateStateHandlers, IContainerLiveObjectStoreEvents } from "./";
import { IAzureAudience } from "@fluidframework/azure-client";
/**
 * @hidden
 * Manager of all of the `LiveObjectSynchronizer` objects
 *
 * @remarks
 * This is intended for use through `LiveShareRuntime`.
 */
export declare class LiveObjectManager extends TypedEventEmitter<IContainerLiveObjectStoreEvents> {
    private readonly _liveRuntime;
    private _containerRuntime;
    private objectStoreMap;
    private _audience?;
    private _synchronizer?;
    private _onBoundReceivedSignalListener?;
    /**
     * Create a new registry for all of the `LiveObjectSynchronizer` objects for a Live Share session.
     * @param _liveRuntime runtime for the Live Share session.
     * @param _containerRuntime signal runtime.
     */
    constructor(_liveRuntime: LiveShareRuntime, _containerRuntime: IContainerRuntimeSignaler);
    /**
     * The update interval in milliseconds
     */
    updateInterval: number;
    /**
     * Start listening for changes
     */
    start(): void;
    /**
     * Stop listening for changes
     */
    stop(): void;
    /**
     * Register your `LiveObjectSynchronizer`.
     *
     * @param id the unique identifier for the synchronizer
     * @param runtime the IRuntimeSignaler made available through the `DataObject`
     * @param initialState the initial state for the session.
     * @param handlers the handlers for getting and updating state
     */
    registerObject<TState>(id: string, runtime: IRuntimeSignaler, initialState: TState, handlers: GetAndUpdateStateHandlers<TState>): Promise<void>;
    /**
     * Unregister your `LiveObjectSynchronizer`.
     *
     * @param id the unique identifier for the synchronizer
     */
    unregisterObject(id: string): void;
    /**
     * Gets the most recent event sent for a given `objectId`.
     * @param objectId the `LiveDataObject` id
     * @returns the latest event sent, or undefined if there is none
     */
    getLatestEventForObject<TState = any>(objectId: string): ILiveEvent<TState> | undefined;
    /**
     * Gets the most recent event sent for a given `objectId` and `clientId`.
     * @param objectId the `LiveDataObject` id
     * @param clientId the client to get the value for
     * @returns the latest event sent, or undefined if there is none
     */
    getLatestEventForObjectClient<TState = any>(objectId: string, clientId: string): ILiveEvent<TState> | undefined;
    /**
     * Gets the events sent for a given `objectId`, sorted by most recent.
     * @param objectId the `LiveDataObject` id
     * @returns the latest events sent, or undefined if there are none
     */
    getEventsForObject<TState = any>(objectId: string): ILiveEvent<TState>[] | undefined;
    /**
     * Sends a one-time event for a given object
     * @param objectId the `LiveDataObject` id
     * @param data the date for the event to send
     * @returns the event that was sent
     */
    sendEventForObject<TState = any>(objectId: string, data: TState): Promise<ILiveEvent<TState>>;
    /**
     * Sends a throttled one-time event for the purposes of consolidating multiple signals into a single one.
     */
    sendThrottledEventForObject<TState = any>(objectId: string, data: TState): Promise<ILiveEvent<TState>>;
    /**
     * @hidden
     * The local client was given a new clientId, move cached events to the new clientId
     */
    clientIdDidChange(originalClientId: string, newClientId: string): void;
    /**
     * @hidden
     * Do not use this API unless you know what you are doing.
     * Using it incorrectly could cause object synchronizers to stop working.
     * @see LiveShareRuntime.__dangerouslySetContainerRuntime
     */
    __dangerouslySetContainerRuntime(cRuntime: IContainerRuntimeSignaler): void;
    /**
     * Set the audience
     */
    setAudience(audience: IAzureAudience): void;
    private onReceivedSignal;
    private dispatchUpdates;
    /**
     * @hidden
     * Updates the local event in memory for a given clientId
     *
     * @returns true if it was inserted, or false if it was skipped because the event is older
     */
    updateEventLocallyInStore(objectId: string, event: ILiveEvent<any>): boolean;
    private startReceivingSignalUpdates;
    private stopReceivingSignalUpdates;
}
//# sourceMappingURL=LiveObjectManager.d.ts.map