/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
import { ITokenProvider } from "@fluidframework/azure-client";
import { IRuntimeSignaler } from "../LiveEventScope";
/**
 * @hidden
 */
export declare function cloneValue<T>(value: T): T;
/**
 * @hidden
 */
export declare function decodeBase64(data: string): string;
/**
 * @hidden
 */
export declare const parseJwt: (token: string) => any;
/**
 * @hidden
 */
export declare function waitForDelay(delay: number): Promise<void>;
/**
 * @hidden
 */
export declare class TimeoutError extends Error {
    constructor();
}
/**
 * @hidden
 */
export declare function waitForResult<TSuccessResult, TRequestResult>(fnRequest: () => Promise<TRequestResult>, fnValidateResponse: (result: TRequestResult) => {
    response: TSuccessResult;
} | null, fnTimeout: (reason: unknown) => Error, retrySchedule: number[], fnRequestError?: (error: unknown) => Error | null, lateFinish?: () => void, basedDelayMilliseconds?: number): Promise<TSuccessResult>;
/**
 * BUGBUG: Workaround for Teams Client not rejecting errors :(
 * @hidden
 */
export declare function timeoutRequest<TResult>(fnRequest: () => Promise<TResult>, timeout: number, lateFinish?: () => void): Promise<TResult>;
/**
 * Dynamically import InsecureTokenProvider class, in case developer does not yet have "@fluidframework/test-client-utils",
 * since don't want to require that they include it in package.json.
 * @hidden
 */
export declare function getInsecureTokenProvider(): Promise<ITokenProvider>;
/**
 * @hidden
 * Waits until connected and gets the most recent clientId
 * @returns clientId
 */
export declare function waitUntilConnected(runtime: IRuntimeSignaler): Promise<string>;
//# sourceMappingURL=utils.d.ts.map