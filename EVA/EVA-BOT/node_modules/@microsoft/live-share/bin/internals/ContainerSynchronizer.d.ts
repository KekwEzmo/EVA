import { IRuntimeSignaler } from "../LiveEventScope";
import { LiveShareRuntime } from "../LiveShareRuntime";
import { IContainerRuntimeSignaler, ILiveEvent } from "../interfaces";
import { GetAndUpdateStateHandlers, StateSyncEventContent } from "./internal-interfaces";
import { LiveObjectManager } from "./LiveObjectManager";
/**
 * @hidden
 */
export declare class ContainerSynchronizer {
    private readonly _runtime;
    private _containerRuntime;
    private readonly _liveRuntime;
    private readonly _objectStore;
    private readonly _objects;
    private _throttledEventsQueue;
    private _connectedKeys;
    private _refCount;
    private _hTimer;
    private _connectSentForClientId?;
    private _onBoundConnectedListener?;
    private _onReceiveObjectUpdateListener?;
    private _onSendUpdatesIntervalCallback?;
    constructor(_runtime: IRuntimeSignaler, _containerRuntime: IContainerRuntimeSignaler, _liveRuntime: LiveShareRuntime, _objectStore: LiveObjectManager);
    registerObject(id: string, handlers: GetAndUpdateStateHandlers<any>): void;
    unregisterObject(id: string): boolean;
    /**
     * On send background updates handler
     *
     * @returns void promise once the events were sent (unless skipped)
     */
    onSendBackgroundUpdates(): Promise<void>;
    /**
     * Sends a one-time event for a given object
     * @param objectId the `LiveDataObject` id
     * @param data the date for the event to send
     * @returns the latest events sent, or undefined if there are none
     */
    sendEventForObject<TState = any>(objectId: string, data: TState): Promise<ILiveEvent<TState>>;
    /**
     * Sends a one-time event that is throttled for the purposes of consolidating multiple signals into a single one.
     * @param objectId the `LiveDataObject` id
     * @param data the date for the event to send
     * @returns the latest events sent, or undefined if there are none
     */
    sendThrottledEventForObject<TState = any>(objectId: string, data: TState): Promise<ILiveEvent<TState>>;
    /**
     * @hidden
     * Send a batch of events
     * @param updates updates to send
     * @param evtType type of event
     * @returns event where data is then StateSyncEventContent containing the batched events that were sent.
     */
    sendEventUpdates(updates: StateSyncEventContent, evtType: string): Promise<ILiveEvent<StateSyncEventContent> | undefined>;
    /**
     * @hidden
     * Do not use this API unless you know what you are doing.
     * Using it incorrectly could cause object synchronizers to stop working.
     * @see LiveShareRuntime.__dangerouslySetContainerRuntime
     */
    __dangerouslySetContainerRuntime(cRuntime: IContainerRuntimeSignaler): void;
    private onConnected;
    private sendGroupEvent;
    /**
     * On received event update
     */
    private onReceiveUpdate;
    /**
     * Waits until connected and gets the most recent clientId
     * @returns clientId
     */
    protected waitUntilConnected(): Promise<string>;
    private startListeningForConnected;
    private stopListeningForConnected;
    private startBackgroundObjectUpdates;
    private stopBackgroundObjectUpdates;
}
//# sourceMappingURL=ContainerSynchronizer.d.ts.map