"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimestampProvider = void 0;
const IMPROVE_ACCURACY_INTERVAL = 5 * 1000;
const IMPROVE_ACCURACY_ATTEMPTS = 5;
/**
 * Default `ITimestampProvider` implementation.
 *
 */
class TimestampProvider {
    constructor() {
        this._retries = 0;
        this._lastTimeSent = 0;
    }
    /**
     * Returns true if the provider has been started.
     */
    get isRunning() {
        return !!this._serverTime;
    }
    /**
     * Returns the current server time as a UTC tick.
     */
    getTimestamp() {
        if (!this._serverTime) {
            throw new Error(`TimestampProvider: can't call getTimestamp() before calling start().`);
        }
        // Return adjusted timestamp and save last
        // - We never want to generate the same timestamp twice and we always want a greater
        //   timestamp then what we previously sent. This can happen if our accuracy improves
        //   and we end up with a smaller offset then before.
        return (this._lastTimeSent = Math.max(new Date().getTime() + this._serverTime.offset, this._lastTimeSent + 1));
    }
    /**
     * Returns the maximum amount of error, in milliseconds.
     */
    getMaxTimestampError() {
        if (!this._serverTime) {
            throw new Error(`DefaultTimestampProvider: can't call getMaxTimestampError() before calling initialize().`);
        }
        return Math.floor(this._serverTime.requestLatency / 2);
    }
    /**
     * Starts the provider.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stop();
            performance.mark(`TeamsSync: starting clock`);
            try {
                yield this.improveAccuracy();
            }
            finally {
                performance.measure(`TeamsSync: clock startup`, `TeamsSync: starting clock`);
            }
        });
    }
    /**
     * Stops the provider if its running.
     */
    stop() {
        if (this._syncTimer) {
            clearTimeout(this._syncTimer);
            this._syncTimer = undefined;
        }
        this._serverTime = undefined;
        this._retries = 0;
    }
    /**
     * Called in a loop to improve the accuracy of the clients timestamp offset.
     *
     * The function will periodically call itself until we go 5 times without an improvement
     * to the calculated timestamp offset.
     */
    improveAccuracy() {
        return __awaiter(this, void 0, void 0, function* () {
            // Check for a more accurate time offset.
            const offset = yield this.getSessionTimeOffset();
            if (!this._serverTime ||
                offset.requestLatency < this._serverTime.requestLatency) {
                // We got a more accurate time offset.
                //this.logger.trace(`SharedClock accuracy improved to ${offset.offset}ms by latency of ${offset.requestLatency}ms.`);
                this._serverTime = offset;
                this._retries = 0;
            }
            else {
                // We got back an equal or less accurate time offset.
                this._retries++;
            }
            // Start sync timer timer
            if (this._retries <= IMPROVE_ACCURACY_ATTEMPTS) {
                this._syncTimer = setTimeout(this.improveAccuracy.bind(this), IMPROVE_ACCURACY_INTERVAL);
            }
            else {
                this._syncTimer = undefined;
            }
        });
    }
    /**
     * Fetches the current timestamp from central timestamp service and computes the local offset.
     * @returns Computed timestamp offset.
     */
    getSessionTimeOffset() {
        return __awaiter(this, void 0, void 0, function* () {
            // Get time from server and measure request time
            const startCall = performance.now();
            const serverTime = yield this.getNtpTime();
            const endCall = performance.now();
            const now = new Date().getTime();
            // Compute request latency and session time.
            const requestLatency = endCall - startCall;
            const serverTimeInUtc = serverTime.ntpTimeInUTC + Math.floor(requestLatency / 2);
            // Return offset
            return {
                serverTimeInUtc: serverTimeInUtc,
                localTimeInUtc: now,
                requestLatency: requestLatency,
                offset: serverTimeInUtc - now,
            };
        });
    }
}
exports.TimestampProvider = TimestampProvider;
//# sourceMappingURL=TimestampProvider.js.map