/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
import { DataObjectFactory } from "@fluidframework/aqueduct";
import { IEvent } from "@fluidframework/common-definitions";
import { UserMeetingRole, IClientTimestamp, ILiveEvent } from "./interfaces";
import { LiveDataObject } from "./LiveDataObject";
/**
 * Events supported by `LiveEvent` object.
 */
export declare enum LiveEventEvents {
    /**
     * An event has been sent or received.
     */
    received = "received"
}
/**
 * Event typings for `LiveEvent` class.
 * @template TEvent Type of event to broadcast.
 */
export interface ILiveEventEvents<TEvent> extends IEvent {
    /**
     * A remote event was received or a local event was sent.
     * @param event Name of event.
     * @param listener Function called when event is triggered.
     * @param listener.evt The event that was sent/received.
     * @param listener.local If true the `evt` is an event that was sent.
     * @param listener.clientId clientId of sender.
     * @param listener.timestamp timestamp the time message was sent, according to `LiveShareRuntime.getTimestamp()`
     */
    (event: "received", listener: (evt: TEvent, local: boolean, clientId: string, timestamp: number) => void): any;
}
/**
 * Live fluid object that broadcasts an event to other clients and a set of static event
 * related helpers.
 *
 * #### remarks
 * Applications should call `on('received', (evt, local) => {})` to listen for local events sent
 * and remote events received. Events aren't guaranteed to be delivered so you should limit their
 * use to sending events you're ok with potentially being missed. Reactions are a good use case for
 * `LiveEvents`. Use something like the `LiveState` class when syncing state.
 * @template TEvent Type of event to broadcast.
 */
export declare class LiveEvent<TEvent = any> extends LiveDataObject<{
    Events: ILiveEventEvents<TEvent>;
}> {
    private _eventTarget?;
    /**
     * The objects fluid type/name.
     */
    static readonly TypeName = "@microsoft/live-share:LiveEvent";
    /**
     * The objects fluid type factory.
     */
    static readonly factory: DataObjectFactory<LiveEvent<any>, import("@fluidframework/aqueduct").DataObjectTypes>;
    /**
     * Initialize the object to begin sending/receiving events through this DDS.
     *
     * @remarks
     * You should register `received` event listeners before calling this function to ensure no incoming events are missed.
     * `received` events will not be emitted until after this function is called.
     *
     * @param allowedRoles Optional. List of roles allowed to send events.
     *
     * @returns a void promise that resolves once complete.
     *
     * @throws error when `.initialize()` has already been called for this class instance.
     */
    initialize(allowedRoles?: UserMeetingRole[]): Promise<void>;
    /**
     * Broadcasts an event to all other clients.
     *
     * @remarks
     * The event will be queued for delivery if the client isn't currently connected.
     *
     * @param evt Event to send. If omitted, an event will still be sent but it won't include any custom event data.
     *
     * @returns A promise with the full event object that was sent, including the timestamp of when the event was sent and the clientId if known.
     * The clientId will be `undefined` if the client is disconnected at time of delivery.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    send(evt: TEvent): Promise<ILiveEvent<TEvent>>;
    /**
     * Returns true if a received event is newer then the current event.
     *
     * @remarks
     * Used when building new Live objects to process state change events. The `isNewer()`
     * method implements an algorithm that deals with conflicting events that have the same timestamp
     * and older events that should have debounced the current event.
     *
     * - When the received event has the same timestamp as the current event, each events clientId
     *   will be used as a tie breaker. The clientId containing the lower sort order wins any ties.
     * - Older events are generally ignored unless a debounce period is specified. An older event
     *   that should have debounced the current event will be considered newer.
     *
     * The algorithm employed by isNewer() helps ensure that all clients will eventually reach a
     * consistent state with one other.
     * @param current Current event to compare received event against.
     * @param received Received event.
     * @param debouncePeriod Optional. Time in milliseconds to ignore any new events for. Defaults to 0 ms.
     * @returns True if the received event is newer then the current event and should replace the current one.
     */
    static isNewer(current: IClientTimestamp | undefined, received: IClientTimestamp, debouncePeriod?: number): boolean;
}
//# sourceMappingURL=LiveEvent.d.ts.map