"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.LiveEventTimer = void 0;
const TimeInterval_1 = require("./TimeInterval");
/**
 * Periodically broadcasts an event to listening `LiveEventTarget` instances.
 */
class LiveEventTimer {
    /**
     * Creates a new `LiveEventTimer instance.
     * @param eventSource Event source that will be used to emit events.
     * @param createEvent Function used to construct an event to send. This will be called at regular intervals prior to sending an event.
     * @param delay Period to delay for in milliseconds.
     * @param repeat Optional. If true the timer will repeat once `start` is called, otherwise a single event will be sent after the delay. Defaults to false.
     */
    constructor(eventSource, createEvent, delay, repeat = false) {
        this._isRunning = false;
        this._eventSource = eventSource;
        this._createEvent = createEvent;
        this._delay = new TimeInterval_1.TimeInterval(delay);
        this.repeat = repeat;
    }
    /**
     * The rate at which the events are sent in milliseconds.
     */
    get delay() {
        return this._delay.milliseconds;
    }
    set delay(value) {
        this._delay.milliseconds = value;
    }
    /**
     * Returns true if the timer is currently running.
     */
    get isRunning() {
        return this._isRunning;
    }
    /**
     * Immediately sends an event.
     *
     * @remarks
     * The `createEvent` callback to construct the event is called but does not impact any pending
     * timeouts. Call `start` after calling `sendEvent` if you'd like to skip the next timer
     * interval.
     */
    sendEvent() {
        const evt = this._createEvent();
        return this._eventSource.sendEvent(evt);
    }
    /**
     * Starts the timer.
     *
     * @remarks
     * If the timer is running it will be stooped and then re-started with a new `delay`.
     */
    start() {
        this.stop();
        this._isRunning = true;
        this.delayedEmit(this.delay);
    }
    /**
     * Stops the timer if its running.
     */
    stop() {
        if (this._timer != undefined) {
            clearTimeout(this._timer);
            this._timer = undefined;
        }
        this._isRunning = false;
    }
    delayedEmit(delay) {
        this._timer = setTimeout(() => {
            this._timer = undefined;
            const startedAt = new Date().getTime();
            this.sendEvent().catch((err) => {
                console.warn(err);
            });
            // Auto-repeat
            if (this._isRunning && this.repeat) {
                // We want to send an every ${this.delay} milliseconds so we subtract the duration
                // of the time it took us to emit the event.  If it took longer then ${this.delay}
                // we will skip to the next interval (hence the %mod% operation.)
                const duration = (new Date().getTime() - startedAt) % this.delay;
                this.delayedEmit(this.delay - duration);
            }
        }, delay);
    }
}
exports.LiveEventTimer = LiveEventTimer;
//# sourceMappingURL=LiveEventTimer.js.map