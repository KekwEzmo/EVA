"use strict";
var __setFunctionName = (this && this.__setFunctionName) || function (f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLiveDataObjectClassProxy = exports.getLiveShareContainerSchemaProxy = void 0;
/**
 * Inject Live Share dependencies into your Fluid container schema.
 * This should only be done once, right before connecting to a container.
 * @remarks
 * Users should not use this method if you are connecting to a container using `LiveShareClient`.
 * This is intended to be used when you are using another Fluid client, such as `AzureClient`.
 *
 * @param schema Fluid ContainerSchema you would like to inject the runtime into
 * @param liveRuntime LiveShareRuntime instance
 * @returns ContainerSchema with injected dependencies
 */
function getLiveShareContainerSchemaProxy(schema, liveRuntime) {
    var _a;
    // Each container must proxy LiveDataObject classes separately.
    // This map is used to de-duplicate proxies for each class.
    const existingProxyRegistries = new Map();
    const initialObjectEntries = Object.entries(schema.initialObjects).map(([key, ObjectClass]) => {
        return [
            key,
            getLiveDataObjectClassProxy(ObjectClass, liveRuntime, existingProxyRegistries),
        ];
    });
    const newInitialObjects = Object.fromEntries(initialObjectEntries);
    return {
        initialObjects: newInitialObjects,
        dynamicObjectTypes: (_a = schema.dynamicObjectTypes) === null || _a === void 0 ? void 0 : _a.map((ObjectClass) => getLiveDataObjectClassProxy(ObjectClass, liveRuntime, existingProxyRegistries)),
    };
}
exports.getLiveShareContainerSchemaProxy = getLiveShareContainerSchemaProxy;
/**
 * @hidden
 * Inject Live Share dependencies to relevant `LiveDataObject` derived classes.
 * Regular `DataObject` classes are not proxied.
 */
function getLiveDataObjectClassProxy(ObjectClass, liveRuntime, existingProxyRegistries = new Map()) {
    if (isLiveDataObject(ObjectClass)) {
        // We should only be proxying one Live Share DDS per type.
        // This is because Fluid attempts to de-duplicate by comparing classes, but we are dynamically creating proxies.
        // They then enforce this de-duplication using the factory type name, throwing an error in `parseDataObjectsFromSharedObjects`.
        // So, we ensure that we only create the proxy once per container.
        const typeName = ObjectClass.TypeName;
        const CheckExisting = existingProxyRegistries.get(typeName);
        if (CheckExisting !== undefined) {
            return CheckExisting;
        }
        // Create a new proxy for this type and insert it into proxiedClasses
        const NewProxy = getLiveDataObjectProxyClassInternal(ObjectClass, liveRuntime);
        existingProxyRegistries.set(typeName, NewProxy);
        return NewProxy;
    }
    return ObjectClass;
}
exports.getLiveDataObjectClassProxy = getLiveDataObjectClassProxy;
/**
 * @hidden
 */
function isLiveDataObject(value) {
    return value.LiveEnabled === true;
}
/**
 * @hidden
 * Create a new class extending LiveDataObject to inject in _liveRuntime
 */
function getLiveDataObjectProxyClassInternal(BaseClass, runtime) {
    var _a;
    class ProxiedBaseClass extends BaseClass {
        constructor(props) {
            // eslint-disable-next-line constructor-super
            super(props);
            this.__dangerouslySetLiveRuntime(runtime);
            // Pass reference to the container runtime
            if (!this.context || !this.context.containerRuntime) {
                throw Error("getLiveDataObjectProxyClassInternal: required dependencies unknown");
            }
            // when interactive is false, that means that this client is from the summarizer or some other system entity.
            // we only want to set the container runtime for interactive clients, so we return.
            if (this.context.clientDetails.capabilities.interactive === false) {
                return;
            }
            runtime.__dangerouslySetContainerRuntime(this.context.containerRuntime);
        }
    }
    const DynamicClass = (_a = class extends BaseClass {
        },
        __setFunctionName(_a, "DynamicClass"),
        _a.TypeName = BaseClass.TypeName,
        _a.factory = new Proxy(BaseClass.factory, {
            get: function (target, prop, receiver) {
                if (prop === "ctor") {
                    return ProxiedBaseClass;
                }
                return Reflect.get(target, prop, receiver);
            },
        }),
        _a);
    return DynamicClass;
}
//# sourceMappingURL=schema-injection-utils.js.map