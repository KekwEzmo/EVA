/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
import { DataObjectFactory } from "@fluidframework/aqueduct";
import { UserMeetingRole } from "./interfaces";
import { IEvent } from "@fluidframework/common-definitions";
import { LiveDataObject } from "./LiveDataObject";
export interface ITimerConfigData {
    /**
     * Duration of timer
     */
    duration: number;
    /**
     * position when config change occurred
     */
    position: number;
    /**
     * Whether the timer was running or not when config change occurred
     */
    running: boolean;
}
export interface ITimerConfig extends ITimerConfigData {
    /**
     * Time the config changed at
     */
    configChangedAt: number;
    /**
     * The clientId that made the change
     */
    clientId: string;
}
/**
 * Events supported by `LiveTimer` object.
 */
export declare enum LiveTimerEvents {
    /**
     * Timer has started
     */
    started = "started",
    /**
     * Paused timer has resumed
     */
    played = "played",
    /**
     * Playing timer has paused
     */
    paused = "paused",
    /**
     * Timer has finished
     */
    finished = "finished",
    /**
     * Timer has progressed
     */
    onTick = "onTick"
}
export interface ILiveTimerEvents extends IEvent {
    (event: "started", listener: (config: ITimerConfig, local: boolean) => void): any;
    (event: "played", listener: (config: ITimerConfig, local: boolean) => void): any;
    (event: "paused", listener: (config: ITimerConfig, local: boolean) => void): any;
    (event: "finished", listener: (config: ITimerConfig) => void): any;
    (event: "onTick", listener: (milliRemaining: number) => void): any;
}
export declare class LiveTimer extends LiveDataObject<{
    Events: ILiveTimerEvents;
}> {
    private _currentConfig;
    private _synchronizer?;
    private _defaultTickRate;
    private _tickRate;
    /**
     * The objects fluid type/name.
     */
    static readonly TypeName = "@microsoft/live-share:LiveTimer";
    /**
     * The objects fluid type factory.
     */
    static readonly factory: DataObjectFactory<LiveTimer, {
        Events: ILiveTimerEvents;
    }>;
    /**
     * Tick rate for timer in milliseconds. The default tick rate is 20 milliseconds
     *
     * @remarks
     * Tick rate is used to evaluate how often onTick callback is called.
     * A high tick rate can also result in the started, played, paused, and finished
     * callbacks being called slightly later.
     *
     * If the tick rate is the default tick rate or lower, timer will tick
     * at the framerate of the browser.
     */
    get tickRate(): number;
    set tickRate(value: number);
    /**
     * Initialize the object to begin sending/receiving timer updates through this DDS.
     *
     * @param allowedRoles Optional. List of roles allowed to make state changes.
     *
     * @returns a void promise that resolves once complete.
     *
     * @throws error when `.initialize()` has already been called for this class instance.
     * @throws fatal error when `.initialize()` has already been called for an object of same id but with a different class instance.
     * This is most common when using dynamic objects through Fluid.
     */
    initialize(allowedRoles?: UserMeetingRole[]): Promise<void>;
    /**
     * Disposes of the object when its container is disposed of.
     */
    dispose(): void;
    /**
     * Starts the timer with a specified duration.
     *
     * @remarks
     * Starting an already started timer will restart the timer with a new duration.
     *
     * @param duration in Milliseconds
     *
     * @returns a void promise that resolves once the start event has been sent to the server
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    start(duration: number): Promise<void>;
    /**
     * Resumes the timer.
     *
     * @remarks
     * Playing an already playing timer does nothing.
     *
     * @returns a void promise that resolves once the play event has been sent to the server
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    play(): Promise<void>;
    private playInternal;
    /**
     * Pauses the timer.
     *
     * @remarks
     * Pausing an already paused timer does nothing.
     *
     * @returns a void promise that resolves once the pause event has been sent to the server
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    pause(): Promise<void>;
    private remoteConfigReceived;
    private updateConfig;
    private startTicking;
    private scheduleAnimationFrame;
    private endTimeFromConfig;
}
//# sourceMappingURL=LiveTimer.d.ts.map