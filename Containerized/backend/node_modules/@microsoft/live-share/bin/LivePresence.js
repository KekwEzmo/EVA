"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LivePresence = exports.LivePresenceEvents = void 0;
const aqueduct_1 = require("@fluidframework/aqueduct");
const LivePresenceUser_1 = require("./LivePresenceUser");
const LiveObjectSynchronizer_1 = require("./LiveObjectSynchronizer");
const LiveTelemetryLogger_1 = require("./LiveTelemetryLogger");
const internals_1 = require("./internals");
const TimeInterval_1 = require("./TimeInterval");
const DynamicObjectRegistry_1 = require("./DynamicObjectRegistry");
const interfaces_1 = require("./interfaces");
const LiveDataObject_1 = require("./LiveDataObject");
/**
 * Events supported by `LivePresence` object.
 */
var LivePresenceEvents;
(function (LivePresenceEvents) {
    /**
     * The presence for the local or a remote user has changed.
     */
    LivePresenceEvents["presenceChanged"] = "presenceChanged";
})(LivePresenceEvents = exports.LivePresenceEvents || (exports.LivePresenceEvents = {}));
/**
 * Live fluid object that synchronizes presence information for the user with other clients.
 * @template TData Type of data object to share with clients.
 */
class LivePresence extends LiveDataObject_1.LiveDataObject {
    constructor() {
        super(...arguments);
        this._expirationPeriod = new TimeInterval_1.TimeInterval(20000);
        this._users = [];
        this._lastEmitPresenceStateMap = new Map();
    }
    /**
     * Number of seconds without a presence update before a remote user is considered offline.
     *
     * @remarks
     * Defaults to a value of `20` seconds. The minimum value is 0.1 seconds for testing purposes.
     */
    get expirationPeriod() {
        return this._expirationPeriod.seconds;
    }
    set expirationPeriod(value) {
        this._expirationPeriod.seconds = value > 0.1 ? value : 0.1;
        this.getUsers().forEach((user) => {
            user.expirationPeriod = this._expirationPeriod;
        });
    }
    /**
     * Local LivePresenceUser.
     * Can be undefined before LivePresence is initialized.
     */
    get localUser() {
        var _a;
        const clientId = (_a = this._currentPresence) === null || _a === void 0 ? void 0 : _a.clientId;
        if (!clientId)
            return undefined;
        return this.getUserForClient(clientId);
    }
    /**
     * Initialize the object to begin sending/receiving presence updates through this DDS.
     *
     * @param data Optional. Custom data object to share. A deep copy of the data object is saved to avoid any accidental modifications.
     * @param state Optional. Initial presence state. Defaults to `PresenceState.online`.
     * @param allowedRoles Optional. List of roles allowed to emit presence changes.
     *
     * @returns a void promise that resolves once complete.
     *
     * @throws error when `.initialize()` has already been called for this class instance.
     * @throws fatal error when `.initialize()` has already been called for an object of same id but with a different class instance.
     * This is most common when using dynamic objects through Fluid.
     */
    initialize(data, state = LivePresenceUser_1.PresenceState.online, allowedRoles) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.needed) {
                throw new Error(`LivePresence already started.`);
            }
            // This error should not happen due to `initializeState` enum, but if it is somehow defined at this point, errors will occur.
            if (this._synchronizer) {
                throw new Error(`LivePresence: _synchronizer already set, which is an unexpected error. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            // Update initialize state as pending
            this.initializeState = interfaces_1.LiveDataObjectInitializeState.pending;
            this._logger = new LiveTelemetryLogger_1.LiveTelemetryLogger(this.runtime, this.liveRuntime);
            // Save off allowed roles
            this._allowedRoles = allowedRoles || [];
            // Set default presence
            this._currentPresence = {
                clientId: yield this.waitUntilConnected(),
                name: "UpdatePresence",
                timestamp: 0,
                data: {
                    state,
                    data,
                },
            };
            // Create object synchronizer
            this._synchronizer = new LiveObjectSynchronizer_1.LiveObjectSynchronizer(this.id, this.runtime, this.liveRuntime);
            try {
                yield this._synchronizer.start(this._currentPresence.data, (state, sender, local) => __awaiter(this, void 0, void 0, function* () {
                    // Add user to list
                    yield this.updateMembersList(state, local);
                    return false;
                }), (connecting) => __awaiter(this, void 0, void 0, function* () {
                    if (connecting)
                        return true;
                    // If user has eligible roles, allow the update to be sent
                    try {
                        return yield this.verifyLocalUserRoles();
                    }
                    catch (_a) {
                        return false;
                    }
                }), true // We want to update the timestamp periodically so that we know if a user is active
                );
            }
            catch (error) {
                // Update initialize state as fatal error
                this.initializeState = interfaces_1.LiveDataObjectInitializeState.fatalError;
                throw error;
            }
            // Update initialize state as succeeded.
            // We do before sending initial update, since that requires this to happen first.
            this.initializeState = interfaces_1.LiveDataObjectInitializeState.succeeded;
            // Broadcast initial presence, or silently fail trying.
            // Throttled so that a developer can have multiple presence instances in their app in a performant manner.
            yield this.updateInternal(this._currentPresence.data.data, this._currentPresence.data.state, true).catch(() => { });
        });
    }
    /**
     * Disposes of the object when its container is disposed of.
     */
    dispose() {
        super.dispose();
        if (this._synchronizer) {
            this._synchronizer.dispose();
        }
    }
    /**
     * Returns a snapshot of the current list of presence objects being tracked.
     * @param filter Optional. Presence state to filter enumeration to.
     * @returns Array of presence objects.
     */
    getUsers(filter) {
        if (!filter)
            return this._users;
        return this._users.filter((user) => user.state == filter);
    }
    /**
     * Updates the local user's presence shared data object and/or state.
     *
     * @remarks
     * This will trigger the immediate broadcast of the users presence to all other clients.
     *
     * @param data Optional. Data object to change. A deep copy of the data object is saved to avoid any future changes.
     * @param state Optional. Presence state to change.
     *
     * @returns a void promise that resolves once the update event has been sent to the server.
     *
     * @throws error if initialization has not yet succeeded.
     * @throws error if the local user does not have the required roles defined through the `allowedRoles` prop in `.initialize()`.
     */
    update(data, state) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.updateInternal(data, state);
        });
    }
    /**
     * Returns the current presence info for a specific client ID.
     * @param clientId The ID of the client to retrieve.
     * @returns The current presence information for the client if they've connected to the space.
     */
    getUserForClient(clientId) {
        return this._users.find((user) => user.isFromClient(clientId));
    }
    /**
     * Returns the current presence info for a specific user.
     * @param userId The ID of the user to retrieve.
     * @returns The current presence information for the user if they've connected to the space.
     */
    getUser(userId) {
        return this._users.find((user) => user.userId == userId);
    }
    /**
     * Internal method to send an update, with optional ability to throttle.
     */
    updateInternal(data, state, throttle = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.initializeState !== interfaces_1.LiveDataObjectInitializeState.succeeded) {
                throw new Error(`LivePresence: not initialized prior to calling \`.update()\`. \`initializeState\` is \`${this.initializeState}\` but should be \`succeeded\`.\nTo fix this error, ensure \`.initialize()\` has resolved before calling this function.`);
            }
            if (!this._synchronizer) {
                throw new Error(`LivePresence: this._synchronizer is undefined, implying there was an error during initialization that should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            if (!this._currentPresence) {
                throw new Error(`LivePresence: this._currentPresence is undefined, implying there was an error during initialization that should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.`);
            }
            // Broadcast state change
            const evtToSend = {
                state: state !== null && state !== void 0 ? state : this._currentPresence.data.state,
                data: (_a = (0, internals_1.cloneValue)(data)) !== null && _a !== void 0 ? _a : this._currentPresence.data.data,
            };
            const evt = throttle
                ? yield this._synchronizer.sendThrottledEvent(evtToSend)
                : yield this._synchronizer.sendEvent(evtToSend);
            yield this.updateMembersList(evt, true);
        });
    }
    /**
     * returns true if the change was applied to the member list
     */
    updateMembersList(evt, localEvent) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const allowed = yield this.liveRuntime.verifyRolesAllowed(evt.clientId, this._allowedRoles);
                if (!allowed)
                    return false;
                // Update local presence immediately
                // - The _updatePresenceEvent won't be triggered until the presence change is actually sent. If
                //   the client is disconnected this could be several seconds later.
                if (localEvent) {
                    this._currentPresence = evt;
                }
                const info = yield this.liveRuntime.getClientInfo(evt.clientId);
                // So if undefined
                if (!info)
                    return false;
                if (this.useTransientParticipantWorkaround(info)) {
                    return this.transientParticipantWorkaround(evt, localEvent, info);
                }
                // normal flow
                return this.updateMembersListWithInfo(evt, localEvent, info);
            }
            catch (err) {
                (_a = this._logger) === null || _a === void 0 ? void 0 : _a.sendErrorEvent(internals_1.TelemetryEvents.LiveState.RoleVerificationError, err);
            }
            return false;
        });
    }
    /**
     * For some reason, for non local users, tmp roster transiently doesn't contain a meeting participant.
     * When the particpant is missing the `info` matches `defaultUserInfo`.
     * @returns true if the info matches the default user info
     */
    useTransientParticipantWorkaround(info) {
        const defaultUserInfo = {
            userId: info.userId,
            roles: [interfaces_1.UserMeetingRole.guest],
            displayName: undefined,
        };
        return JSON.stringify(info) === JSON.stringify(defaultUserInfo);
    }
    /**
     * Uses `updateMembersListWithInfo` with the latest value rather than using the incorrect default client info response.
     * @returns true if user presence record was updated
     */
    transientParticipantWorkaround(evt, localEvent, info) {
        // when participant is missing, use existing information instead.
        const user = this._users.find((user) => user.userId === info.userId);
        if (user) {
            const existingInfo = {
                userId: user.userId,
                roles: user.roles,
                displayName: user.displayName,
            };
            return this.updateMembersListWithInfo(evt, localEvent, existingInfo);
        }
        // This user has not yet been inserted, so we attempt to insert it with defaultUserInfo
        return this.updateMembersListWithInfo(evt, localEvent, info);
    }
    updateMembersListWithInfo(evt, localEvent, info) {
        const emitEvent = (user) => {
            var _a, _b;
            this._lastEmitPresenceStateMap.set(user.userId, user.state);
            this.emit(LivePresenceEvents.presenceChanged, user, localEvent, evt.clientId);
            if (localEvent) {
                (_a = this._logger) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(internals_1.TelemetryEvents.LivePresence.LocalPresenceChanged, null, { user: JSON.stringify(evt) });
            }
            else {
                (_b = this._logger) === null || _b === void 0 ? void 0 : _b.sendTelemetryEvent(internals_1.TelemetryEvents.LivePresence.RemotePresenceChanged, null, { user: JSON.stringify(evt) });
            }
        };
        let didUpdate = false;
        let isNewUser = true;
        for (let pos = 0; pos < this._users.length; pos++) {
            const checkUser = this._users[pos];
            if (info.userId === checkUser.userId) {
                // User found. Apply update and check for changes
                if (checkUser.updateReceived(evt, info, localEvent)) {
                    emitEvent(checkUser);
                    didUpdate = true;
                }
                isNewUser = false;
            }
            else if (this._lastEmitPresenceStateMap.get(checkUser.userId) !==
                checkUser.state) {
                // The user's PresenceState has changed
                emitEvent(checkUser);
                didUpdate = true;
            }
        }
        if (!isNewUser)
            return didUpdate;
        // Insert new user and send change event
        const newUser = new LivePresenceUser_1.LivePresenceUser(info, evt, this._expirationPeriod, this.liveRuntime, localEvent);
        this._users.push(newUser);
        emitEvent(newUser);
        return true;
    }
}
/**
 * The objects fluid type/name.
 */
LivePresence.TypeName = `@microsoft/live-share:LivePresence`;
/**
 * The objects fluid type factory.
 */
LivePresence.factory = new aqueduct_1.DataObjectFactory(LivePresence.TypeName, LivePresence, [], {});
exports.LivePresence = LivePresence;
/**
 * Register `LivePresence` as an available `LoadableObjectClass` for use in packages that support dynamic object loading, such as `@microsoft/live-share-turbo`.
 */
DynamicObjectRegistry_1.DynamicObjectRegistry.registerObjectClass(LivePresence, LivePresence.TypeName);
//# sourceMappingURL=LivePresence.js.map