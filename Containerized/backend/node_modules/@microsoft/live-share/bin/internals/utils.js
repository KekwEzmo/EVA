"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitUntilConnected = exports.getInsecureTokenProvider = exports.timeoutRequest = exports.waitForResult = exports.TimeoutError = exports.waitForDelay = exports.parseJwt = exports.decodeBase64 = exports.cloneValue = void 0;
const uuid_1 = require("uuid");
/**
 * @hidden
 */
function cloneValue(value) {
    return typeof value == "object" ? JSON.parse(JSON.stringify(value)) : value;
}
exports.cloneValue = cloneValue;
/**
 * @hidden
 */
function decodeBase64(data) {
    if (typeof atob == "function") {
        return atob(data);
    }
    else {
        return Buffer.from(data, "base64").toString();
    }
}
exports.decodeBase64 = decodeBase64;
/**
 * @hidden
 */
const parseJwt = (token) => {
    try {
        return JSON.parse(decodeBase64(token.split(".")[1]));
    }
    catch (e) {
        return null;
    }
};
exports.parseJwt = parseJwt;
/**
 * @hidden
 */
function waitForDelay(delay) {
    return new Promise((resolve) => {
        setTimeout(() => resolve(), delay);
    });
}
exports.waitForDelay = waitForDelay;
/**
 * @hidden
 */
class TimeoutError extends Error {
    constructor() {
        super("timed out");
    }
}
exports.TimeoutError = TimeoutError;
/**
 * @hidden
 */
function waitForResult(fnRequest, fnValidateResponse, fnTimeout, retrySchedule, fnRequestError, lateFinish, basedDelayMilliseconds = 1000) {
    let retries = 0;
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        while (true) {
            try {
                const result = yield timeoutRequest(fnRequest, Math.max(basedDelayMilliseconds * (retries + 1), basedDelayMilliseconds * 3), lateFinish);
                const validated = fnValidateResponse(result);
                if (validated !== null) {
                    resolve(validated.response);
                    break;
                }
                else if (retries >= retrySchedule.length) {
                    reject(new Error("waitForResult: invalid response"));
                    break;
                }
            }
            catch (error) {
                if (retries >= retrySchedule.length) {
                    reject(fnTimeout(error));
                    break;
                }
                // Check if this error is something that should cause us to skip the retry schedule
                if (!!fnRequestError && !(error instanceof TimeoutError)) {
                    const rejectNowError = fnRequestError(error);
                    if (rejectNowError !== null) {
                        reject(rejectNowError);
                        break;
                    }
                }
            }
            yield waitForDelay(retrySchedule[retries++]);
        }
    }));
}
exports.waitForResult = waitForResult;
/**
 * BUGBUG: Workaround for Teams Client not rejecting errors :(
 * @hidden
 */
function timeoutRequest(fnRequest, timeout, lateFinish) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        let hTimer = setTimeout(() => {
            reject(new TimeoutError());
            hTimer = null;
        }, timeout);
        try {
            const result = yield fnRequest();
            resolve(result);
            if (hTimer == null) {
                lateFinish === null || lateFinish === void 0 ? void 0 : lateFinish();
            }
        }
        catch (error) {
            reject(error);
            if (hTimer == null) {
                lateFinish === null || lateFinish === void 0 ? void 0 : lateFinish();
            }
        }
        clearTimeout(hTimer);
    }));
}
exports.timeoutRequest = timeoutRequest;
/**
 * Dynamically import InsecureTokenProvider class, in case developer does not yet have "@fluidframework/test-client-utils",
 * since don't want to require that they include it in package.json.
 * @hidden
 */
function getInsecureTokenProvider() {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { InsecureTokenProvider } = yield require("@fluidframework/test-client-utils");
            const userIdParam = (_b = (_a = new URL(window.location.href)) === null || _a === void 0 ? void 0 : _a.searchParams) === null || _b === void 0 ? void 0 : _b.get("userId");
            const tokenProvider = new InsecureTokenProvider("", {
                id: userIdParam !== null && userIdParam !== void 0 ? userIdParam : (0, uuid_1.v4)(),
                name: "Test User",
            });
            return tokenProvider;
        }
        catch (_c) {
            throw new Error("@microsoft/live-share: when using 'local' connection type, you must have @fluidframework/test-client-utils installed");
        }
    });
}
exports.getInsecureTokenProvider = getInsecureTokenProvider;
/**
 * @hidden
 * Waits until connected and gets the most recent clientId
 * @returns clientId
 */
function waitUntilConnected(runtime) {
    return new Promise((resolve) => {
        const onConnected = (clientId) => {
            runtime.off("connected", onConnected);
            resolve(clientId);
        };
        if (runtime.clientId) {
            resolve(runtime.clientId);
        }
        else {
            runtime.on("connected", onConnected);
        }
    });
}
exports.waitUntilConnected = waitUntilConnected;
//# sourceMappingURL=utils.js.map