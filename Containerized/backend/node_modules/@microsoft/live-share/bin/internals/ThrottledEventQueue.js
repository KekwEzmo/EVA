"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThrottledEventQueue = void 0;
const Deferred_1 = require("./Deferred");
const consts_1 = require("./consts");
/**
 * @hidden
 * Queue for grouping multiple signal events together.
 *
 * @remarks
 * See {@link ContainerSynchronizer} for usage.
 */
class ThrottledEventQueue {
    /**
     * @hidden
     * Queue for grouping multiple signal events together.
     *
     * @param synchronizer container synchronizer to send the events through
     * @param throttleIntervalMilli interval for throttling
     */
    constructor(synchronizer, throttleIntervalMilli = 50) {
        this._events = {};
        this._containerSynchronizer = synchronizer;
        this._throttleIntervalMilli = throttleIntervalMilli;
    }
    /**
     * Send an event with a queue.
     * This will schedule a new batch to be sent if one is not already scheduled.
     */
    sendWithQueue(objectId, event) {
        return __awaiter(this, void 0, void 0, function* () {
            this._events[objectId] = event;
            if (!this._hTimer) {
                this._deferred = new Deferred_1.Deferred();
                this._hTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b;
                    try {
                        const response = yield this._containerSynchronizer.sendEventUpdates(this._events, consts_1.ObjectSynchronizerEvents.update);
                        if (!response) {
                            throw new Error("ThrottledEventQueue: unable to send empty set of updates, which should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.");
                        }
                        (_a = this._deferred) === null || _a === void 0 ? void 0 : _a.resolve(response);
                    }
                    catch (error) {
                        (_b = this._deferred) === null || _b === void 0 ? void 0 : _b.reject(error);
                    }
                    finally {
                        this._events = {};
                        this._hTimer = undefined;
                    }
                }), this._throttleIntervalMilli);
            }
            if (!this._deferred) {
                throw new Error("ThrottledEventQueue: no deferred set, which should not occur. Please report this issue at https://aka.ms/teamsliveshare/issue.");
            }
            const response = yield this._deferred.promise;
            return {
                clientId: response.clientId,
                timestamp: response.data[objectId].timestamp,
                name: response.name,
                data: response.data[objectId].data,
            };
        });
    }
}
exports.ThrottledEventQueue = ThrottledEventQueue;
//# sourceMappingURL=ThrottledEventQueue.js.map