"use strict";
/*!
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the Microsoft Live Share SDK License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackwardsCompatibilityHostDecorator = void 0;
const BaseHostDecorator_1 = require("./BaseHostDecorator");
const RequestCache_1 = require("./RequestCache");
const type_guards_1 = require("./type-guards");
const utils_1 = require("./utils");
const EXPONENTIAL_BACKOFF_SCHEDULE = [100, 200, 200, 400, 600];
const CACHE_LIFETIME = 5 * 60 * 1000; // original cache time
/**
 * @hidden
 * Decorator that provides backwards compatibility for getClientInfo
 * If getClientInfo does not exist on an unsupported client, `IUserInfo.displayName` will be undefined
 *
 * For internal use only. Will be deleted.
 */
class BackwardsCompatibilityHostDecorator extends BaseHostDecorator_1.BaseHostDecorator {
    /**
     * @hidden
     * _host would be `BackwardsCompatibilityHostDecorator` decorator: `new BackwardsCompatibilityHostDecorator(new LiveShareHostDecorator(teamsJsHost))`
     */
    constructor(_host) {
        super(_host);
        this._host = _host;
        this._userRolesRequestCache = new RequestCache_1.RequestCache(CACHE_LIFETIME);
        this._totalTries = 4;
        this._getClientInfoTriesRemaining = this._totalTries;
        this._getClientInfoExists = false;
        this._hasWarnedPolyfill = false;
        this.warmupCheckGetClientInfoExists();
    }
    /**
     * @deprecated
     */
    getClientRoles(clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!clientId) {
                throw new Error(`BackwardsCompatibilityHostDecorator: called getClientInfo() without a clientId`);
            }
            return this._userRolesRequestCache.cacheRequest(clientId, () => {
                return (0, utils_1.waitForResult)(() => __awaiter(this, void 0, void 0, function* () {
                    return yield this._host.getClientRoles(clientId);
                }), (result) => {
                    if ((0, type_guards_1.isClientRolesResponse)(result)) {
                        return {
                            response: result,
                        };
                    }
                    else if ((0, type_guards_1.isMobileWorkaroundRolesResponse)(result)) {
                        return {
                            response: result.userRoles,
                        };
                    }
                    return null;
                }, () => {
                    return new Error(`BackwardsCompatibilityHostDecorator: timed out getting roles for a remote client ID`);
                }, EXPONENTIAL_BACKOFF_SCHEDULE);
            });
        });
    }
    getClientInfo(clientId) {
        return __awaiter(this, void 0, void 0, function* () {
            // 1. fire getClientInfo and getClientRoles at same time.
            //    - on new versions of teams client getClientInfo and getClientRoles share same network cache, cheap to call.
            //    - on old versions of teams client getClientRoles needs to be called anyway.
            // 2. if getClientInfo resolves, return that
            // 3. if getClientInfo times out, return polyfil using getClientRoles, log warning
            // 4. if getClientInfo times out after multiple calls, start using only polyfill.
            if (this._getClientInfoExists) {
                return yield this._host.getClientInfo(clientId);
            }
            if (this._getClientInfoTriesRemaining <= 0) {
                if (!this._hasWarnedPolyfill) {
                    console.warn("BackwardsCompatibilityHostDecorator.getClientInfo: using getClientInfo polyfill");
                    this._hasWarnedPolyfill = true;
                }
                const roles = yield this.getClientRoles(clientId);
                return {
                    userId: clientId,
                    displayName: undefined,
                    roles: roles !== null && roles !== void 0 ? roles : [],
                };
            }
            const getClientRoles = this.getClientRoles(clientId);
            try {
                const clientInfo = yield this._host.getClientInfo(clientId, () => {
                    // The request initially timed out, but then it later was rejected/resolved for a legitimate reason
                    this._getClientInfoExists = true;
                }, this.getRetrySchedule());
                this._getClientInfoExists = true;
                return clientInfo;
            }
            catch (error) {
                if ((0, type_guards_1.isErrorLike)(error) && error.message.includes("timed out")) {
                    this._getClientInfoTriesRemaining--;
                    if (this._getClientInfoTriesRemaining <= 0) {
                        console.warn("BackwardsCompatibilityHostDecorator.getClientInfo: will use getClientInfo polyfill");
                    }
                    const roles = yield getClientRoles;
                    return {
                        userId: clientId,
                        displayName: undefined,
                        roles: roles !== null && roles !== void 0 ? roles : [],
                    };
                }
            }
            this._getClientInfoExists = true;
            // retry schedule gets longer as we lose confidence it exists.
            // First call to this._host.getClientInfo may result in an error if the api exists, but without retries.
            // If error we know the api exists. call the normal implementation again.
            // this should only ever be hit one time at the start because this._getClientInfoExists will be true.
            console.log("BackwardsCompatibilityHostDecorator: error, retryingWithActual");
            return yield this.getClientInfo(clientId);
        });
    }
    warmupCheckGetClientInfoExists() {
        if (this._getClientInfoExists)
            return;
        // warmup doesn't use polyfill implementation
        // "fakeId" clientId, error expected, hopefully not a timeout
        this._host
            .getClientInfo("fakeId", () => {
            // The request initially timed out, but then it later was rejected/resolved for a legitimate reason
            this._getClientInfoExists = true;
        }, [])
            .catch((e) => {
            if (e.message.includes("timed out")) {
                this._getClientInfoTriesRemaining--;
                if (this._getClientInfoTriesRemaining > 0) {
                    this.warmupCheckGetClientInfoExists();
                }
                else {
                    console.warn("BackwardsCompatibilityHostDecorator.getClientInfo: will use getClientInfo polyfill");
                }
            }
            else {
                // resolved for reason other than timeout, api exists
                this._getClientInfoExists = true;
            }
        });
    }
    // retry little bit longer when getting to end of retries remaining.
    getRetrySchedule() {
        const retryAmount = this._totalTries - Math.max(0, this._getClientInfoTriesRemaining);
        return EXPONENTIAL_BACKOFF_SCHEDULE.slice(0, retryAmount);
    }
}
exports.BackwardsCompatibilityHostDecorator = BackwardsCompatibilityHostDecorator;
//# sourceMappingURL=BackwardsCompatibilityHostDecorator.js.map